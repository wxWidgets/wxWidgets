\section{\class{wxScrolledWindow}}\label{wxscrolledwindow}

The wxScrolledWindow class manages scrolling for its client area, transforming
the coordinates according to the scrollbar positions, and setting the
scroll positions, thumb sizes and ranges according to the area in view.

As with all windows, an application can draw onto a wxScrolledWindow using a \helpref{device context}{dcoverview}.

You have the option of handling the \helpref{OnPaint}{wxscrolledwindowonpaint} handler
or overriding the \helpref{OnDraw}{wxscrolledwindowondraw} function, which is passed
a pre-scrolled device context (prepared by \helpref{PrepareDC}{wxscrolledwindowpreparedc}).

If you don't wish to calculate your own scrolling, you must call PrepareDC when not drawing from
within OnDraw, to set the device origin for the device context according to the current
scroll position.

\wxheading{Derived from}

\helpref{wxWindow}{wxwindow}\\
\helpref{wxEvtHandler}{wxevthandler}\\
\helpref{wxObject}{wxobject}

\wxheading{Window styles}

\twocolwidtha{5cm}
\begin{twocollist}\itemsep=0pt
\twocolitem{\windowstyle{wxRETAINED}}{Uses a backing pixmap to speed refreshes. Motif only.}
\end{twocollist}

See also \helpref{window styles overview}{windowstyles}.

\wxheading{Remarks}

Use wxScrolledWindow for applications where the user scrolls by a fixed amount, and
where a `page' can be interpreted to be the current visible portion of the window. For
more sophisticated applications, use the wxScrolledWindow implementation as a guide
to build your own scroll behaviour.

\wxheading{See also}

\helpref{wxScrollBar}{wxscrollbar}, \helpref{wxClientDC}{wxclientdc}, \helpref{wxPaintDC}{wxpaintdc}

\latexignore{\rtfignore{\wxheading{Members}}}

\membersection{wxScrolledWindow::wxScrolledWindow}\label{wxscrolledwindowconstr}

\func{}{wxScrolledWindow}{\void}

Default constructor.

\func{}{wxScrolledWindow}{\param{wxWindow*}{ parent}, \param{const wxWindowID }{id = -1},\rtfsp
\param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{const long}{ style = wxHSCROLL \pipe wxVSCROLL}, \param{const wxString\& }{name = ``scrolledWindow"}}

Constructor.

\wxheading{Parameters}

\docparam{parent}{Parent window.}

\docparam{id}{Window identifier. A value of -1 indicates a default value.}

\docparam{pos}{Window position. If a position of (-1, -1) is specified then a default position
is chosen.}

\docparam{size}{Window size. If a size of (-1, -1) is specified then the window is sized
appropriately.}

\docparam{style}{Window style. See \helpref{wxScrolledWindow}{wxscrolledwindow}.}

\docparam{name}{Window name.}

\wxheading{Remarks}

The window is initially created without visible scrollbars.
Call \helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars} to
specify how big the virtual window size should be.

\membersection{wxScrolledWindow::\destruct{wxScrolledWindow}}

\func{}{\destruct{wxScrolledWindow}}{\void}

Destructor.

\membersection{wxScrolledWindow::Create}\label{wxscrolledwindowcreate}

\func{bool}{Create}{\param{wxWindow*}{ parent}, \param{const wxWindowID }{id = -1},\rtfsp
\param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{const long}{ style = wxHSCROLL \pipe wxVSCROLL}, \param{const wxString\& }{name = ``scrolledWindow"}}

Creates the window for two-step construction. Derived classes
should call or replace this function. See \helpref{wxScrolledWindow::wxScrolledWindow}{wxscrolledwindowconstr}\rtfsp
for details.

\membersection{wxScrolledWindow::EnableScrolling}\label{wxscrolledwindowenablescrolling}

\func{void}{EnableScrolling}{\param{const bool}{ xScrolling}, \param{const bool}{ yScrolling}}

Enable or disable physical scrolling in the given direction. Physical
scrolling is the physical transfer of bits up or down the
screen when a scroll event occurs. If the application scrolls by a
variable amount (e.g. if there are different font sizes) then physical
scrolling will not work, and you should switch it off.

\wxheading{Parameters}

\docparam{xScrolling}{If TRUE, enables physical scrolling in the x direction.}

\docparam{yScrolling}{If TRUE, enables physical scrolling in the y direction.}

\wxheading{Remarks}

Physical scrolling may not be available on all platforms. Where it is available, it is enabled
by default.

\membersection{wxScrolledWindow::GetScrollPixelsPerUnit}\label{wxscrolledwindowgetscrollpixelsperunit}

\constfunc{void}{GetScrollPixelsPerUnit}{\param{int* }{xUnit}, \param{int* }{yUnit}}

Get the number of pixels per scroll unit (line), in each direction, as set
by \helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars}. A value of zero indicates no
scrolling in that direction.

\wxheading{Parameters}

\docparam{xUnit}{Receives the number of pixels per horizontal unit.}

\docparam{yUnit}{Receives the number of pixels per vertical unit.}

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetVirtualSize}{wxscrolledwindowgetvirtualsize},\rtfsp
\helpref{wxWindow::GetScrollPage}{wxwindowgetscrollpage}

\membersection{wxScrolledWindow::GetVirtualSize}\label{wxscrolledwindowgetvirtualsize}

\constfunc{void}{GetVirtualSize}{\param{int* }{x}, \param{int* }{y}}

Gets the size in device units of the scrollable window area (as
opposed to the client size, which is the area of the window currently
visible).

\wxheading{Parameters}

\docparam{x}{Receives the length of the scrollable window, in pixels.}

\docparam{y}{Receives the height of the scrollable window, in pixels.}

\wxheading{Remarks}

Use \helpref{wxDC::DeviceToLogicalX}{wxdcdevicetologicalx} and \helpref{wxDC::DeviceToLogicalY}{wxdcdevicetologicaly}\rtfsp
to translate these units to logical units.

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetScrollPixelsPerUnit}{wxscrolledwindowgetscrollpixelsperunit},\rtfsp
\helpref{wxWindow::GetScrollPage}{wxwindowgetscrollpage}

\membersection{wxScrolledWindow::IsRetained}\label{wxscrolledwindowisretained}

\constfunc{bool}{IsRetained}{\void}

TRUE if the window has a backing bitmap.

\membersection{wxScrolledWindow::PrepareDC}\label{wxscrolledwindowpreparedc}

\func{void}{PrepareDC}{\param{wxDC\& }{dc}}

Call this function to prepare the device context for drawing a scrolled image. It
sets the device origin according to the current scroll position.

PrepareDC is called automatically within the default \helpref{wxScrolledWindow::OnPaint}{wxscrolledwindowonpaint} event
handler, so your \helpref{wxScrolledWindow::OnDraw}{wxscrolledwindowondraw} override
will be passed a 'pre-scrolled' device context. However, if you wish to draw from
outside of OnDraw (via OnPaint), or you wish to implement OnPaint yourself, you must
call this function yourself. For example:

\begin{verbatim}
void MyCanvas::OnEvent(wxMouseEvent& event)
{
  wxClientDC dc(this);
  PrepareDC(dc);

  dc.SetPen(*wxBLACK_PEN);
  float x, y;
  event.Position(&x, &y);
  if (xpos > -1 && ypos > -1 && event.Dragging())
  {
    dc.DrawLine(xpos, ypos, x, y);
  }
  xpos = x;
  ypos = y;
}
\end{verbatim}

\membersection{wxScrolledWindow::OnDraw}\label{wxscrolledwindowondraw}

\func{virtual void}{OnDraw}{\param{wxDC\& }{dc}}

Called by the default \helpref{wxScrolledWindow::OnPaint}{wxscrolledwindowonpaint} implementation
to allow the application to define painting behaviour without having to worry about
calling \helpref{wxScrolledWindow::PrepareDC}{wxscrolledwindowpreparedc}.

\membersection{wxScrolledWindow::OnPaint}\label{wxscrolledwindowonpaint}

\func{void}{OnPaint}{\param{wxPaintEvent\& }{event}}

Sent to the window when the window must be refreshed.

For more details, see \helpref{wxWindow::OnPaint}{wxwindowonpaint}.

The default implementation for wxScrolledWindow's OnPaint handler is simply:

\begin{verbatim}
void wxScrolledWindow::OnPaint(wxPaintEvent& event)
{
	wxPaintDC dc(this);
	PrepareDC(dc);

	OnDraw(dc);
}
\end{verbatim}

\membersection{wxScrolledWindow::OnScroll}\label{wxscrolledwindowonscroll}

\func{void}{OnScroll}{\param{wxScrollEvent\& }{event}}

Override this function to intercept scroll events. This
member function implements the default scroll behaviour. If
you do not call the default function, you will have to manage
all scrolling behaviour including drawing the window contents
at an appropriate position relative to the scrollbars.

For more details, see \helpref{wxWindow::OnScroll}{wxwindowonscroll}.

\wxheading{See also}

\helpref{wxScrollEvent}{wxscrollevent}

\membersection{wxScrolledWindow::Scroll}\label{wxscrolledwindowscroll}

\func{void}{Scroll}{\param{int}{ x}, \param{int}{ y}}

Scrolls a window so the view start is at the given point.

\wxheading{Parameters}

\docparam{x}{The x position to scroll to, in scroll units.}

\docparam{y}{The y position to scroll to, in scroll units.}

\wxheading{Remarks}

The positions are in scroll units, not pixels, so to convert to pixels you
will have to multiply by the number of pixels per scroll increment.
If either parameter is -1, that position will be ignored (no change in
that direction).

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetScrollPixelsPerUnit}{wxscrolledwindowgetscrollpixelsperunit}

\membersection{wxScrolledWindow::SetScrollbars}\label{wxscrolledwindowsetscrollbars}

\func{void}{SetScrollbars}{\param{int}{ pixelsPerUnitX}, \param{int}{ pixelsPerUnitY},\rtfsp
\param{int}{ noUnitsX}, \param{int}{ noUnitsY},\rtfsp
\param{int }{xPos = 0}, \param{int}{ yPos = 0}}

Sets up vertical and/or horizontal scrollbars.

\wxheading{Parameters}

\docparam{pixelsPerUnitX}{Pixels per scroll unit in the horizontal direction.}

\docparam{pixelsPerUnitY}{Pixels per scroll unit in the vertical direction.}

\docparam{noUnitsX}{Number of units in the horizontal direction.}

\docparam{noUnitsY}{Number of units in the vertical direction.}

\docparam{xPos}{Position to initialize the scrollbars in the horizontal direction, in scroll units.}

\docparam{yPos}{Position to initialize the scrollbars in the vertical direction, in scroll units.}

\wxheading{Remarks}

The first pair of parameters give the number of pixels per `scroll step', i.e. amount
moved when the up or down scroll arrows are pressed.
The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual
window.

{\it xPos} and {\it yPos} optionally specify a position to scroll to immediately.

For example, the following gives a window horizontal and vertical
scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000
pixels) in each direction.

\begin{verbatim}
  window->SetScrollbars(20, 20, 50, 50);
\end{verbatim}

wxScrolledWindow manages the page size itself,
using the current client window size as the page size.

Note that for more sophisticated scrolling applications, for example where
scroll steps may be variable according to the position in the document, it will be
necessary to derive a new class from wxWindow, overriding {\bf OnSize} and
adjusting the scrollbars appropriately.

\membersection{wxScrolledWindow::ViewStart}\label{wxscrolledwindowviewstart}

\constfunc{void}{ViewStart}{\param{int* }{x}, \param{int* }{ y}}

Get the position at which the visible portion of the window starts.

\wxheading{Parameters}

\docparam{x}{Receives the first visible x position in scroll units.}

\docparam{y}{Receives the first visible y position in scroll units.}

\wxheading{Remarks}

If either of the scrollbars is not at the home position, {\it x} and/or
\rtfsp{\it y} will be greater than zero.  Combined with \helpref{wxWindow::GetClientSize}{wxwindowgetclientsize},
the application can use this function to efficiently redraw only the
visible portion of the window.  The positions are in logical scroll
units, not pixels, so to convert to pixels you will have to multiply
by the number of pixels per scroll increment.

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars}

