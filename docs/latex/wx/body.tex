\chapter{Introduction}\label{introduction}
\pagenumbering{arabic}%
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

\section{What is wxWidgets?}\label{whatis}

wxWidgets is a C++ framework providing GUI (Graphical User
Interface) and other facilities on more than one platform.  Version 2 currently
supports all desktop versions of MS Windows, Unix with GTK+, Unix with Motif,
and MacOS. An OS/2 port is in progress.

wxWidgets was originally developed at the Artificial Intelligence
Applications Institute, University of Edinburgh, for internal use,
and was first made publicly available in 1992.
Version 2 is a vastly improved version written and maintained by
Julian Smart, Robert Roebling, Vadim Zeitlin, Vaclav Slavik and many others.

This manual contains a class reference and topic overviews.
For a selection of wxWidgets tutorials, please see the documentation page on the \urlref{wxWidgets web site}{http://www.wxwidgets.org}.

Please note that in the following, ``MS Windows" often refers to all
platforms related to Microsoft Windows, including 16-bit and 32-bit
variants, unless otherwise stated. All trademarks are acknowledged.

\section{Why another cross-platform development tool?}\label{why}

wxWidgets was developed to provide a cheap and flexible way to maximize
investment in GUI application development.  While a number of commercial
class libraries already existed for cross-platform development,
none met all of the following criteria:

\begin{enumerate}\itemsep=0pt
\item low price;
\item source availability;
\item simplicity of programming;
\item support for a wide range of compilers.
\end{enumerate}

Since wxWidgets was started, several other free or almost-free
GUI frameworks have emerged. However, none has the range of
features, flexibility, documentation and the well-established
development team that wxWidgets has.

As open source software, wxWidgets has benefited from comments,
ideas, bug fixes, enhancements and the sheer enthusiasm of
users. This gives wxWidgets a certain advantage over its
commercial competitors (and over free libraries without an
independent development team), plus a robustness against the
transience of one individual or company. This openness and
availability of source code is especially important when the
future of thousands of lines of application code may depend upon
the longevity of the underlying class library.

Version 2 goes much further than previous versions in terms of
generality and features, allowing applications to be produced
that are often indistinguishable from those produced using
single-platform toolkits such as Motif, GTK+ and MFC.

The importance of using a platform-independent class library
cannot be overstated, since GUI application development is very
time-consuming, and sustained popularity of particular GUIs
cannot be guaranteed. Code can very quickly become obsolete if
it addresses the wrong platform or audience.  wxWidgets helps to
insulate the programmer from these winds of change. Although
wxWidgets may not be suitable for every application (such as an
OLE-intensive program), it provides access to most of the
functionality a GUI program normally requires, plus many extras
such as network programming, PostScript output, and HTML
rendering; and it can of course be extended as needs dictate.
As a bonus, it provides a far cleaner and easier programming
interface than the native APIs. Programmers may find it
worthwhile to use wxWidgets even if they are developing on only
one platform.

It is impossible to sum up the functionality of wxWidgets in a few paragraphs, but
here are some of the benefits:

\begin{itemize}\itemsep=0pt
\item Low cost (free, in fact!)
\item You get the source.
\item Available on a variety of popular platforms.
\item Works with almost all popular C++ compilers and Python.
\item Over 50 example programs.
\item Over 1000 pages of printable and on-line documentation.
\item Includes Tex2RTF, to allow you to produce your own documentation
in Windows Help, HTML and Word RTF formats.
\item Simple-to-use, object-oriented API.
\item Flexible event system.
\item Graphics calls include lines, rounded rectangles, splines, polylines, etc.
\item Constraint-based and sizer-based layouts.
\item Print/preview and document/view architectures.
\item Toolbar, notebook, tree control, advanced list control classes.
\item PostScript generation under Unix, normal MS Windows printing on the PC.
\item MDI (Multiple Document Interface) support.
\item Can be used to create DLLs under Windows, dynamic libraries on Unix.
\item Common dialogs for file browsing, printing, colour selection, etc.
\item Under MS Windows, support for creating metafiles and copying
them to the clipboard.
\item An API for invoking help from applications.
\item Ready-to-use HTML window (supporting a subset of HTML).
\item Network support via a family of socket and protocol classes.
\item Support for platform independent image processing.
\item Built-in support for many file formats (BMP, PNG, JPEG, GIF, XPM, PNM, PCX).
\end{itemize}

\begin{comment}
\section{Changes from version 2.0}\label{versionchanges20}

These are a few of the differences between versions 2.0 and 2.2.

Removals:

\begin{itemize}\itemsep=0pt
\item GTK 1.0 no longer supported.
\end{itemize}

Additions and changes:

\begin{itemize}\itemsep=0pt
\item Corrected many classes to conform better to documented behaviour.
\item Added handlers for more image formats (Now GIF, JPEG, PCX, BMP, XPM, PNG, PNM).
\item Improved support for socket and network functions.
\item Support for different national font encodings.
\item Sizer based layout system.
\item HTML widget and help system.
\item Added some controls (e.g. wxSpinCtrl) and supplemented many.
\item Many optical improvements to GTK port.
\item Support for menu accelerators in GTK port.
\item Enhanced and improved support for scrolling, including child windows.
\item Complete rewrite of clipboard and drag and drop classes.
\item Improved support for ODBC databases.
\item Improved tab traversal in dialogs.
\end{itemize}
\end{comment}

\section{wxWidgets requirements}\label{requirements}

To make use of wxWidgets, you currently need one of the following setups.

(a) MS-Windows:

\begin{enumerate}\itemsep=0pt
\item A 32-bit or 64-bit PC running MS Windows.
\item A Windows compiler: MS Visual C++ (embedded Visual C++ for wxWinCE
port), Borland C++, Watcom C++, Cygwin, MinGW, Metrowerks CodeWarrior,
Digital Mars C++. See {\tt install.txt} for details about compiler 
version supported.
\item At least 100 MB of disk space for source tree and additional space for 
libraries and application building (depends on compiler and build settings).
\end{enumerate}

(b) Unix:

\begin{enumerate}\itemsep=0pt
\item Almost any C++ compiler, including GNU C++ (EGCS 1.1.1 or above).
\item Almost any Unix workstation, and one of: GTK+ 1.2, GTK+ 2.0, Motif 1.2 or higher, Lesstif.
If using the wxX11 port, no such widget set is required.
\item At least 100 MB of disk space for source tree and additional space for 
libraries and application building (depends on compiler and build settings).
\end{enumerate}

(c) Mac OS/Mac OS X:

\begin{enumerate}\itemsep=0pt
\item A PowerPC Mac running Mac OS 8.6/9.x (eg. Classic) or Mac OS X 10.x.
\item CodeWarrior 5.3, 6 or 7 for Classic Mac OS.
\item The Apple Developer Tools (eg. GNU C++), CodeWarrior 7 or above for Mac OS X.
\item At least 100 MB of disk space for source tree and additional space for 
libraries and application building (depends on compiler and build settings).
\end{enumerate}

\section{Availability and location of wxWidgets}\label{where}

\winhelponly{wxWidgets is available by anonymous FTP and World Wide Web
from ftp://biolpc22.york.ac.uk/pub and/or http://www.wxwidgets.org.}
\winhelpignore{wxWidgets is available by anonymous FTP and World Wide Web
from \urlref{ftp://biolpc22.york.ac.uk/pub}{ftp://biolpc22.york.ac.uk/pub} 
and/or \urlref{http://www.wxwidgets.org}{http://www.wxwidgets.org}.}

You can also buy a CD-ROM using the form on the Web site.

\section{Acknowledgements}\label{acknowledgements}

Thanks are due to AIAI for being willing to release the original version of
wxWidgets into the public domain, and to our patient partners.

We would particularly like to thank the following for their contributions to wxWidgets, and the many others who have been involved in
the project over the years. Apologies for any unintentional omissions from this list. 
 
Yiorgos Adamopoulos, Jamshid Afshar, Alejandro Aguilar-Sierra, AIAI, 
Patrick Albert, Karsten Ballueder, Mattia Barbon, Michael Bedward, 
Kai Bendorf, Yura Bidus, Keith Gary Boyce, Chris Breeze, Pete Britton, 
Ian Brown, C. Buckley, Marco Cavallini, Dmitri Chubraev, Robin Corbet, Cecil Coupe, 
Stefan Csomor, Andrew Davison, Gilles Depeyrot, Neil Dudman, Robin Dunn, 
Hermann Dunkel, Jos van Eijndhoven, Chris Elliott, David Elliott, Tom Felici, 
Thomas Fettig, Matthew Flatt, Pasquale Foggia, Josep Fortiana, Todd Fries, 
Dominic Gallagher, Guillermo Rodriguez Garcia, Wolfram Gloger, Norbert Grotz, 
Stefan Gunter, Bill Hale, Patrick Halke, Stefan Hammes, Guillaume Helle, 
Harco de Hilster, Kevin Hock, Cord Hockemeyer, Markus Holzem, Olaf Klein, Leif Jensen, 
Bart Jourquin, Guilhem Lavaux, Ron Lee, Jan Lessner, Nicholas Liebmann, 
Torsten Liermann, Per Lindqvist, Thomas Runge, Tatu M\"{a}nnist\"{o}, 
Scott Maxwell, Thomas Myers, Oliver Niedung, Stefan Neis, Ryan Norton, Hernan Otero, 
Ian Perrigo, Timothy Peters, Giordano Pezzoli, Harri Pasanen, Thomaso Paoletti, 
Garrett Potts, Marcel Rasche, Robert Roebling, Dino Scaringella, 
Jobst Schmalenbach, Arthur Seaton, Paul Shirley, Wlodzimierz `ABX' Skiba, 
Vaclav Slavik, Julian Smart, Stein Somers, Petr Smilauer, Neil Smith, 
Kari Syst\"{a}, George Tasker, Arthur Tetzlaff-Deas, Jonathan Tonberg, 
Jyrki Tuomi, Janos Vegh, Andrea Venturoli, David Webster, Otto Wyss, 
Vadim Zeitlin, Xiaokun Zhu, Edward Zimmermann.

`Graphplace', the basis for the wxGraphLayout library, is copyright Dr. Jos
T.J. van Eijndhoven of Eindhoven University of Technology. The code has
been used in wxGraphLayout with his permission.

We also acknowledge the author of XFIG, the excellent Unix drawing tool,
from the source of which we have borrowed some spline drawing code.
His copyright is included below.

{\it XFig2.1 is copyright (c) 1985 by Supoj Sutanthavibul. Permission to
use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of M.I.T. not be used in advertising or
publicity pertaining to distribution of the software without specific,
written prior permission.  M.I.T. makes no representations about the
suitability of this software for any purpose.  It is provided ``as is''
without express or implied warranty.}

\chapter{Multi-platform development with wxWidgets}\label{multiplat}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter describes the practical details of using wxWidgets. Please
see the file install.txt for up-to-date installation instructions, and
changes.txt for differences between versions.

\section{Include files}\label{includefiles}

The main include file is {\tt "wx/wx.h"}; this includes the most commonly
used modules of wxWidgets.

To save on compilation time, include only those header files relevant to the
source file. If you are using precompiled headers, you should include
the following section before any other includes:

\begin{verbatim}
// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

... now your other include files ...
\end{verbatim}

The file {\tt "wx/wxprec.h"} includes {\tt "wx/wx.h"}. Although this incantation
may seem quirky, it is in fact the end result of a lot of experimentation,
and several Windows compilers to use precompilation which is largely automatic for
compilers with necessary support. Currently it is used for Visual C++ (including
embedded Visual C++), Borland C++, Open Watcom C++, Digital Mars C++
and newer versions of GCC.
Some compilers might need extra work from the application developer to set the
build environment up as necessary for the support.

\section{Libraries}\label{libraries}

Most ports of wxWidgets can create either a static library or a shared
library. wxWidgets can also be built in multilib and monolithic variants.
See the \helpref{libraries list}{librarieslist} for more
information on these.

\section{Configuration}\label{configuration}

When using project files and makefiles directly to build wxWidgets,
options are configurable in the file
\rtfsp{\tt "wx/XXX/setup.h"} where XXX is the required platform (such as msw, motif, gtk, mac). Some 
settings are a matter of taste, some help with platform-specific problems, and
others can be set to minimize the size of the library. Please see the setup.h file
and {\tt install.txt} files for details on configuration.

When using the 'configure' script to configure wxWidgets (on Unix and other platforms where
configure is available), the corresponding setup.h files are generated automatically
along with suitable makefiles. When using the RPM packages
for installing wxWidgets on Linux, a correct setup.h is shipped in the package and
this must not be changed.

\section{Makefiles}\label{makefiles}

On Microsoft Windows, wxWidgets has a different set of makefiles for each
compiler, because each compiler's 'make' tool is slightly different.
Popular Windows compilers that we cater for, and the corresponding makefile
extensions, include: Microsoft Visual C++ (.vc), Borland C++ (.bcc),
OpenWatcom C++ (.wat) and MinGW/Cygwin (.gcc). Makefiles are provided
for the wxWidgets library itself, samples, demos, and utilities.

On Linux, Mac and OS/2, you use the 'configure' command to
generate the necessary makefiles. You should also use this method when
building with MinGW/Cygwin on Windows.

We also provide project files for some compilers, such as
Microsoft VC++. However, we recommend using makefiles
to build the wxWidgets library itself, because makefiles
can be more powerful and less manual intervention is required.

On Windows using a compiler other than MinGW/Cygwin, you would
build the wxWidgets library from the build/msw directory
which contains the relevant makefiles.

On Windows using MinGW/Cygwin, and on Unix, MacOS X and OS/2, you invoke
'configure' (found in the top-level of the wxWidgets source hierarchy),
from within a suitable empty directory for containing makefiles, object files and
libraries.

For details on using makefiles, configure, and project files,
please see docs/xxx/install.txt in your distribution, where
xxx is the platform of interest, such as msw, gtk, x11, mac.

\section{Windows-specific files}\label{windowsfiles}

wxWidgets application compilation under MS Windows requires at least one
extra file: a resource file.

\subsection{Resource file}\label{resources}

The least that must be defined in the Windows resource file (extension RC)
is the following statement:

\begin{verbatim}
#include "wx/msw/wx.rc"
\end{verbatim}

which includes essential internal wxWidgets definitions.  The resource script
may also contain references to icons, cursors, etc., for example:

\begin{verbatim}
wxicon icon wx.ico
\end{verbatim}

The icon can then be referenced by name when creating a frame icon. See
the MS Windows SDK documentation.

\normalbox{Note: include wx.rc {\it after} any ICON statements
so programs that search your executable for icons (such
as the Program Manager) find your application icon first.}

\section{Allocating and deleting wxWidgets objects}\label{allocatingobjects}

In general, classes derived from wxWindow must dynamically allocated
with {\it new} and deleted with {\it delete}. If you delete a window,
all of its children and descendants will be automatically deleted,
so you don't need to delete these descendants explicitly.

When deleting a frame or dialog, use {\bf Destroy} rather than {\bf delete} so
that the wxWidgets delayed deletion can take effect. This waits until idle time
(when all messages have been processed) to actually delete the window, to avoid
problems associated with the GUI sending events to deleted windows.

Don't create a window on the stack, because this will interfere
with delayed deletion.

If you decide to allocate a C++ array of objects (such as wxBitmap) that may
be cleaned up by wxWidgets, make sure you delete the array explicitly
before wxWidgets has a chance to do so on exit, since calling {\it delete} on
array members will cause memory problems.

wxColour can be created statically: it is not automatically cleaned
up and is unlikely to be shared between other objects; it is lightweight
enough for copies to be made.

Beware of deleting objects such as a wxPen or wxBitmap if they are still in use.
Windows is particularly sensitive to this: so make sure you
make calls like wxDC::SetPen(wxNullPen) or wxDC::SelectObject(wxNullBitmap) before deleting
a drawing object that may be in use. Code that doesn't do this will probably work
fine on some platforms, and then fail under Windows.

\section{Architecture dependency}\label{architecturedependency}

A problem which sometimes arises from writing multi-platform programs is that
the basic C types are not defined the same on all platforms. This holds true
for both the length in bits of the standard types (such as int and long) as 
well as their byte order, which might be little endian (typically
on Intel computers) or big endian (typically on some Unix workstations). wxWidgets
defines types and macros that make it easy to write architecture independent
code. The types are:

wxInt32, wxInt16, wxInt8, wxUint32, wxUint16 = wxWord, wxUint8 = wxByte

where wxInt32 stands for a 32-bit signed integer type etc. You can also check
which architecture the program is compiled on using the wxBYTE\_ORDER define
which is either wxBIG\_ENDIAN or wxLITTLE\_ENDIAN (in the future maybe wxPDP\_ENDIAN
as well).

The macros handling bit-swapping with respect to the applications endianness
are described in the \helpref{Byte order macros}{byteordermacros} section.

\section{Conditional compilation}\label{conditionalcompilation}

One of the purposes of wxWidgets is to reduce the need for conditional
compilation in source code, which can be messy and confusing to follow.
However, sometimes it is necessary to incorporate platform-specific
features (such as metafile use under MS Windows). The symbols
listed in the file {\tt symbols.txt} may be used for this purpose,
along with any user-supplied ones.

\section{C++ issues}\label{cpp}

The following documents some miscellaneous C++ issues.

\subsection{Templates}\label{templates}

wxWidgets does not use templates (except for some advanced features that
are switched off by default) since it is a notoriously unportable feature.

\subsection{RTTI}\label{rtti}

wxWidgets does not use C++ run-time type information since wxWidgets provides
its own run-time type information system, implemented using macros.

\subsection{Type of NULL}\label{null}

Some compilers (e.g. the native IRIX cc) define NULL to be 0L so that
no conversion to pointers is allowed. Because of that, all these
occurrences of NULL in the GTK+ port use an explicit conversion such 
as

{\small
\begin{verbatim}
  wxWindow *my_window = (wxWindow*) NULL;
\end{verbatim}
}%

It is recommended to adhere to this in all code using wxWidgets as
this make the code (a bit) more portable.

\subsection{Precompiled headers}\label{precompiledheaders}

Some compilers, such as Borland C++ and Microsoft C++, support
precompiled headers. This can save a great deal of compiling time. The
recommended approach is to precompile {\tt "wx.h"}, using this
precompiled header for compiling both wxWidgets itself and any
wxWidgets applications. For Windows compilers, two dummy source files
are provided (one for normal applications and one for creating DLLs)
to allow initial creation of the precompiled header.

However, there are several downsides to using precompiled headers. One
is that to take advantage of the facility, you often need to include
more header files than would normally be the case. This means that
changing a header file will cause more recompilations (in the case of
wxWidgets, everything needs to be recompiled since everything includes {\tt "wx.h"}!)

A related problem is that for compilers that don't have precompiled
headers, including a lot of header files slows down compilation
considerably. For this reason, you will find (in the common
X and Windows parts of the library) conditional
compilation that under Unix, includes a minimal set of headers;
and when using Visual C++, includes {\tt wx.h}. This should help provide
the optimal compilation for each compiler, although it is
biased towards the precompiled headers facility available
in Microsoft C++.

\section{File handling}\label{filehandling}

When building an application which may be used under different
environments, one difficulty is coping with documents which may be
moved to different directories on other machines. Saving a file which
has pointers to full pathnames is going to be inherently unportable. One
approach is to store filenames on their own, with no directory
information.  The application searches through a number of locally
defined directories to find the file. To support this, the class {\bf
wxPathList} makes adding directories and searching for files easy, and
the global function {\bf wxFileNameFromPath} allows the application to
strip off the filename from the path if the filename must be stored.
This has undesirable ramifications for people who have documents of the
same name in different directories.

As regards the limitations of DOS 8+3 single-case filenames versus
unrestricted Unix filenames, the best solution is to use DOS filenames
for your application, and also for document filenames {\it if} the user
is likely to be switching platforms regularly. Obviously this latter
choice is up to the application user to decide.  Some programs (such as
YACC and LEX) generate filenames incompatible with DOS; the best
solution here is to have your Unix makefile rename the generated files
to something more compatible before transferring the source to DOS.
Transferring DOS files to Unix is no problem, of course, apart from EOL
conversion for which there should be a utility available (such as
dos2unix).

See also the File Functions section of the reference manual for
descriptions of miscellaneous file handling functions.

\chapter{Utilities and libraries supplied with wxWidgets}\label{utilities}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

In addition to the core wxWidgets library, a number of further
libraries and utilities are supplied with each distribution.

Some are under the 'contrib' hierarchy which mirrors the
structure of the main wxWidgets hierarchy. See also the 'utils'
hierarchy. The first place to look for documentation about
these tools and libraries is under the wxWidgets 'docs' hierarchy,
for example {\tt docs/htmlhelp/fl.chm}.

For other user-contributed packages, please see the Contributions page
on the \urlref{wxWidgets Web site}{http://www.wxwidgets.org}.

\begin{description}\itemsep=0pt
\item[{\bf Helpview}]
Helpview is a program for displaying wxWidgets HTML
Help files. In many cases, you may wish to use the wxWidgets HTML
Help classes from within your application, but this provides a
handy stand-alone viewer. See \helpref{wxHTML Notes}{wxhtml} for more details.
You can find it in {\tt samples/html/helpview}.
\item[{\bf Tex2RTF}]
Supplied with wxWidgets is a utility called Tex2RTF for converting\rtfsp
\LaTeX\ manuals HTML, MS HTML Help, wxHTML Help, RTF, and Windows
Help RTF formats. Tex2RTF is used for the wxWidgets manuals and can be used independently
by authors wishing to create on-line and printed manuals from the same\rtfsp
\LaTeX\ source. Please see the separate documentation for Tex2RTF.
You can find it under {\tt utils/tex2rtf}.
\item[{\bf Helpgen}]
Helpgen takes C++ header files and generates a Tex2RTF-compatible
documentation file for each class it finds, using comments as appropriate.
This is a good way to start a reference for a set of classes.
Helpgen can be found in {\tt utils/HelpGen}.
\item[{\bf Emulator}]
Xnest-based display emulator for X11-based PDA applications. On some
systems, the Xnest window does not synchronise with the
'skin' window. This program can be found in {\tt utils/emulator}.
\item[{\bf XRC resource system}]
This is the sizer-aware resource system, and uses
XML-based resource specifications that can be generated by tools
such as \urlref{wxDesigner}{http://www.roebling.de}.
You can find this in {\tt src/xrc}, {\tt include/wx/xrc}, {\tt samples/xrc}.
For more information, see the \helpref{XML-based resource system overview}{xrcoverview}.
\item[{\bf Net library}]
Net is a collection of very simple mail and web related classes. Currently
there is only wxEmail, which makes it easy to send email messages via MAPI on Windows or sendmail on Unix.
You can find this in {\tt contrib/src/net} and {\tt contrib/include/wx/net}.
\item[{\bf Styled Text Control library}]
STC is a wrapper around Scintilla, a syntax-highlighting text editor.
You can find this in {\tt src/stc}, {\tt include/wx/stc}, and {\tt samples/stc}.
\end{description}

\chapter{Programming strategies}\label{strategies}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter is intended to list strategies that may be useful when
writing and debugging wxWidgets programs. If you have any good tips,
please submit them for inclusion here.

\section{Strategies for reducing programming errors}\label{reducingerrors}

\subsection{Use ASSERT}\label{useassert}

Although I haven't done this myself within wxWidgets, it is good
practice to use ASSERT statements liberally, that check for conditions that
should or should not hold, and print out appropriate error messages.
These can be compiled out of a non-debugging version of wxWidgets
and your application. Using ASSERT is an example of `defensive programming':
it can alert you to problems later on.

\subsection{Use wxString in preference to character arrays}\label{usewxstring}

Using wxString can be much safer and more convenient than using wxChar *.
Again, I haven't practiced what I'm preaching, but I'm now trying to use
wxString wherever possible. You can reduce the possibility of memory
leaks substantially, and it is much more convenient to use the overloaded
operators than functions such as strcmp. wxString won't add a significant
overhead to your program; the overhead is compensated for by easier
manipulation (which means less code).

The same goes for other data types: use classes wherever possible.

\section{Strategies for portability}\label{portability}

\subsection{Use relative positioning or constraints}\label{userelativepositioning}

Don't use absolute panel item positioning if you can avoid it. Different GUIs have
very differently sized panel items. Consider using the constraint system, although this
can be complex to program.

Alternatively, you could use alternative .wrc (wxWidgets resource files) on different
platforms, with slightly different dimensions in each. Or space your panel items out
to avoid problems.

\subsection{Use wxWidgets resource files}\label{useresources}

Use .xrc (wxWidgets resource files) where possible, because they can be easily changed
independently of source code.

\section{Strategies for debugging}\label{debugstrategies}

\subsection{Positive thinking}\label{positivethinking}

It is common to blow up the problem in one's imagination, so that it seems to threaten
weeks, months or even years of work. The problem you face may seem insurmountable:
but almost never is. Once you have been programming for some time, you will be able
to remember similar incidents that threw you into the depths of despair. But
remember, you always solved the problem, somehow!

Perseverance is often the key, even though a seemingly trivial problem
can take an apparently inordinate amount of time to solve. In the end,
you will probably wonder why you worried so much. That's not to say it
isn't painful at the time. Try not to worry -- there are many more important
things in life.

\subsection{Simplify the problem}\label{simplifyproblem}

Reduce the code exhibiting the problem to the smallest program possible
that exhibits the problem. If it is not possible to reduce a large and
complex program to a very small program, then try to ensure your code
doesn't hide the problem (you may have attempted to minimize the problem
in some way: but now you want to expose it).

With luck, you can add a small amount of code that causes the program
to go from functioning to non-functioning state. This should give a clue
to the problem. In some cases though, such as memory leaks or wrong
deallocation, this can still give totally spurious results!

\subsection{Use a debugger}\label{usedebugger}

This sounds like facetious advice, but it is surprising how often people
don't use a debugger. Often it is an overhead to install or learn how to
use a debugger, but it really is essential for anything but the most
trivial programs.

\subsection{Use logging functions}\label{uselogging}

There is a variety of logging functions that you can use in your program:
see \helpref{Logging functions}{logfunctions}.

Using tracing statements may be more convenient than using the debugger
in some circumstances (such as when your debugger doesn't support a lot
of debugging code, or you wish to print a bunch of variables).

\subsection{Use the wxWidgets debugging facilities}\label{usedebuggingfacilities}

You can use wxDebugContext to check for
memory leaks and corrupt memory: in fact in debugging mode, wxWidgets will
automatically check for memory leaks at the end of the program if wxWidgets is suitably
configured. Depending on the operating system and compiler, more or less
specific information about the problem will be logged.

You should also use \helpref{debug macros}{debugmacros} as part of a `defensive programming' strategy,
scattering wxASSERTs liberally to test for problems in your code as early as possible. Forward thinking
will save a surprising amount of time in the long run.

See the \helpref{debugging overview}{debuggingoverview} for further information.

