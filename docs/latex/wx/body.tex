\chapter{Introduction}\label{introduction}
\pagenumbering{arabic}%
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

\section{What is wxWindows?}

wxWindows is a C++ framework providing GUI (Graphical User
Interface) and other facilities on more than one platform.  Version 2.0 currently
supports MS Windows (16-bit, Windows 95 and Windows NT) and GTK+, with Motif
and Mac ports in an advanced state.

wxWindows was originally developed at the Artificial Intelligence
Applications Institute, University of Edinburgh, for internal use.
wxWindows has been released into the public domain in the hope
that others will also find it useful. Version 2.0 is written and
maintained by Julian Smart, Robert Roebling and others.

This manual discusses wxWindows in the context of multi-platform
development.\helpignore{For more detail on the wxWindows version 2.0 API
(Application Programming Interface) please refer to the separate
wxWindows reference manual.}

Please note that in the following, ``MS Windows" often refers to all
platforms related to Microsoft Windows, including 16-bit and 32-bit
variants, unless otherwise stated. All trademarks are acknowledged.

\section{Why another cross-platform development tool?}

wxWindows was developed to provide a cheap and flexible way to maximize
investment in GUI application development.  While a number of commercial
class libraries already existed for cross-platform development,
none met all of the following criteria:

\begin{enumerate}\itemsep=0pt
\item low price;
\item source availability;
\item simplicity of programming;
\item support for a wide range of compilers.
\end{enumerate}

Since wxWindows was started, several other free or almost-free GUI frameworks have
emerged. However, none has the range of features, flexibility, documentation and the
well-established development team that wxWindows has.

As public domain software and a project open to everyone, wxWindows has
benefited from comments, ideas, bug fixes, enhancements and the sheer
enthusiasm of users, especially via the Internet. This gives wxWindows a
certain advantage over its commercial competitors (and over free libraries
without an independent development team), plus a robustness against
the transience of one individual or company. This openness and
availability of source code is especially important when the future of
thousands of lines of application code may depend upon the longevity of
the underlying class library.

Version 2.0 goes much further than previous versions in terms of generality and features,
allowing applications to be produced
that are often indistinguishable from those produced using single-platform
toolkits such as Motif and MFC.

The importance of using a platform-independent class library cannot be
overstated, since GUI application development is very time-consuming,
and sustained popularity of particular GUIs cannot be guaranteed.
Code can very quickly become obsolete if it addresses the wrong
platform or audience.  wxWindows helps to insulate the programmer from
these winds of change. Although wxWindows may not be suitable for
every application (such as an OLE-intensive program), it provides access to most of the functionality a
GUI program normally requires, plus some extras such as network programming
and PostScript output, and can of course be extended as needs dictate.  As a bonus, it provides
a cleaner programming interface than the native
APIs. Programmers may find it worthwhile to use wxWindows even if they
are developing on only one platform.

It is impossible to sum up the functionality of wxWindows in a few paragraphs, but
here are some of the benefits:

\begin{itemize}\itemsep=0pt
\item Low cost (free, in fact!)
\item You get the source.
\item Available on a variety of popular platforms.
\item Works with almost all popular C++ compilers.
\item Several example programs.
\item Over 700 pages of printable and on-line documentation.
\item Includes Tex2RTF, to allow you to produce your own documentation
in Windows Help, HTML and Word RTF formats.
\item Simple-to-use, object-oriented API.
\item Flexible event system.
\item Graphics calls include lines, rounded rectangles, splines, polylines, etc.
\item Constraint-based layout option.
\item Print/preview and document/view architectures.
\item Toolbar, notebook, tree control, advanced list control classes.
\item PostScript generation under Unix, normal MS Windows printing on the
PC.
\item MDI (Multiple Document Interface) support.
\item Can be used to create DLLs under Windows, dynamic libraries on Unix.
\item Common dialogs for file browsing, printing, colour selection, etc.
\item Under MS Windows, support for creating metafiles and copying
them to the clipboard.
\item An API for invoking help from applications.
\item Dialog Editor for building dialogs.
\item Network support via a family of socket and protocol classes.
\end{itemize}

\section{Changes from version 1.xx}\label{versionchanges}

These are a few of the major differences between versions 1.xx and 2.0.

Removals:

\begin{itemize}\itemsep=0pt
\item XView is no longer supported;
\item all controls (panel items) no longer have labels attached to them;
\item wxForm has been removed;
\item wxCanvasDC, wxPanelDC removed (replaced by wxClientDC, wxWindowDC, wxPaintDC which
can be used for any window);
\item wxMultiText, wxTextWindow, wxText removed and replaced by wxTextCtrl;
\item classes no longer divided into generic and platform-specific parts, for efficiency.
\end{itemize}

Additions and changes:

\begin{itemize}\itemsep=0pt
\item class hierarchy changed, and restrictions about subwindow nesting lifted;
\item header files reorganised to conform to normal C++ standards;
\item classes less dependent on each another, to reduce executable size;
\item wxString used instead of char* wherever possible;
\item the number of separate but mandatory utilities reduced;
\item the event system has been overhauled, with
virtual functions and callbacks being replaced with MFC-like event tables;
\item new controls, such as wxTreeCtrl, wxListCtrl, wxSpinButton;
\item less inconsistency about what events can be handled, so for example
mouse clicks or key presses on controls can now be intercepted;
\item the status bar is now a separate class, wxStatusBar, and is
implemented in generic wxWindows code;
\item some renaming of controls for greater consistency;
\item wxBitmap has the notion of bitmap handlers to allow for extension to new formats
without ifdefing;
\item new dialogs: wxPageSetupDialog, wxFileDialog, wxDirDialog,
wxMessageDialog, wxSingleChoiceDialog, wxTextEntryDialog;
\item GDI objects are reference-counted and are now passed to most functions
by reference, making memory management far easier;
\item wxSystemSettings class allows querying for various system-wide properties
such as dialog font, colours, user interface element sizes, and so on;
\item better platform look and feel conformance;
\item toolbar functionality now separated out into a family of classes with the
same API;
\item device contexts are no longer accessed using wxWindow::GetDC - they are created
temporarily with the window as an argument;
\item events from sliders and scrollbars can be handled more flexibly;
\item the handling of window close events has been changed in line with the new
event system;
\item the concept of {\it validator} has been added to allow much easier coding of
the relationship between controls and application data;
\item the documentation has been revised, with more cross-referencing.
\end{itemize}

Platform-specific changes:

\begin{itemize}\itemsep=0pt
\item The Windows header file (windows.h) is no longer included by wxWindows headers;
\item wx.dll supported under Visual C++;
\item the full range of Windows 95 window decorations are supported, such as modal frame
borders;
\item MDI classes brought out of wxFrame into separate classes, and made more flexible.
\end{itemize}

\section{wxWindows requirements}\label{requirements}

To make use of wxWindows, you currently need one or both of the
following setups.

(a) PC:

\begin{enumerate}\itemsep=0pt
\item A 486 or higher PC running MS Windows.
\item A Windows compiler: most are supported, but please see {\tt install.txt} for
details. Supported compilers include Microsoft Visual C++ 4.0 or higher, Borland C++, Cygwin,
Metrowerks CodeWarrior.
\item At least 60 MB of disk space.
\end{enumerate}

(b) Unix:

\begin{enumerate}\itemsep=0pt
\item Almost any C++ compiler, including GNU C++.
\item Almost any Unix workstation, and one of: GTK+ 1.0, Motif 1.2 or higher, Lesstif.
\item At least 60 MB of disk space.
\end{enumerate}

\section{Availability and location of wxWindows}

wxWindows is currently available from the Artificial Intelligence
Applications Institute by anonymous FTP and World Wide Web:

\begin{verbatim}
  ftp://www.remstar.com/pub/wxwin
  http://web.ukonline.co.uk/julian.smart/wxwin
\end{verbatim}

\section{Acknowledgments}

Thanks are due to AIAI for being willing to release the original version of
wxWindows into the public domain, and to our patient partners.

We would particularly like to thank the following for their contributions to wxWindows, and the many others who have been involved in
the project over the years. Apologies for any unintentional omissions from this list. 
 
Yiorgos Adamopoulos, Jamshid Afshar, Alejandro Aguilar-Sierra, AIAI, Patrick Albert, Karsten Ballueder, Michael Bedward, Kai Bendorf, Yura Bidus, Keith 
Gary Boyce, Chris Breeze, Pete Britton, Ian Brown, C. Buckley, Dmitri Chubraev, Robin Corbet, Cecil Coupe, Andrew Davison, Neil Dudman, Robin 
Dunn, Hermann Dunkel, Jos van Eijndhoven, Tom Felici, Thomas Fettig, Matthew Flatt, Pasquale Foggia, Josep Fortiana, Todd Fries, Dominic Gallagher, 
Wolfram Gloger, Norbert Grotz, Stefan Gunter, Bill Hale, Patrick Halke, Stefan Hammes, Guillaume Helle, Harco de Hilster, Cord Hockemeyer, Markus 
Holzem, Olaf Klein, Leif Jensen, Bart Jourquin, Guilhem Lavaux, Jan Lessner, Nicholas Liebmann, Torsten Liermann, Per Lindqvist, Thomas Runge, Tatu
M\"{a}nnist\"{o}, Scott Maxwell, Thomas Myers, Oliver Niedung, Hernan Otero, Ian Perrigo, Timothy Peters, Giordano Pezzoli, Harri Pasanen, Thomaso Paoletti, 
Garrett Potts, Marcel Rasche, Robert Roebling, Dino Scaringella, Jobst Schmalenbach, Arthur Seaton, Paul Shirley, Stein Somers, Petr Smilauer, Neil Smith, 
Kari Syst\"{a}, Arthur Tetzlaff-Deas, Jonathan Tonberg, Jyrki Tuomi, Janos Vegh, Andrea Venturoli, Vadim Zeitlin, Xiaokun Zhu, Edward Zimmermann.

`Graphplace', the basis for the wxGraphLayout library, is copyright Dr. Jos
T.J. van Eijndhoven of Eindhoven University of Technology. The code has
been used in wxGraphLayout with his permission.

We also acknowledge the author of XFIG, the excellent Unix drawing tool,
from the source of which we have borrowed some spline drawing code.
His copyright is included below.

{\it XFig2.1 is copyright (c) 1985 by Supoj Sutanthavibul. Permission to
use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of M.I.T. not be used in advertising or
publicity pertaining to distribution of the software without specific,
written prior permission.  M.I.T. makes no representations about the
suitability of this software for any purpose.  It is provided ``as is''
without express or implied warranty.}

\chapter{Multi-platform development with wxWindows}\label{multiplat}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter describes the practical details of using wxWindows. Please
see the file install.txt for up-to-date installation instructions, and
changes.txt for differences between versions.

\section{Include files}

The main include file is {\tt "wx/wx.h"}; this includes the most commonly
used modules of wxWindows.

To save on compilation time, include only those header files relevant to the
source file. If you are using precompiled headers, you should include
the following section before any other includes:

\begin{verbatim}
// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

... now your other include files ...
\end{verbatim}

The file {\tt "wx/wxprec.h"} includes {\tt "wx/wx.h"}. Although this incantation
may seem quirky, it is in fact the end result of a lot of experimentation,
and several Windows compilers to use precompilation (those tested are Microsoft Visual C++, Borland C++
and Watcom C++).

Borland precompilation is largely automatic. Visual C++ requires specification of {\tt "wx/wxprec.h"} as
the file to use for precompilation. Watcom C++ is automatic apart from the specification of
the .pch file. Watcom C++ is strange in requiring the precompiled header to be used only for
object files compiled in the same directory as that in which the precompiled header was created.
Therefore, the wxWindows Watcom C++ makefiles go through hoops deleting and recreating
a single precompiled header file for each module, thus preventing an accumulation of many
multi-megabyte .pch files.

\section{Libraries}

Please the wxGTK or wxMotif documentation for use of the Unix version of wxWindows.
Under Windows, use the library wx.lib for stand-alone Windows
applications, or wxdll.lib for creating DLLs.

\section{Configuration}

Options are configurable in the file
\rtfsp{\tt "wx/XXX/setup.h"} where XXX is the required platform (such as msw, motif, gtk, mac). Some settings are a matter
of taste, some help with platform-specific problems, and
others can be set to minimize the size of the library. Please see the setup.h file
and {\tt install.txt} files for details on configuration.

\section{Makefiles}

At the moment there is no attempt to make Unix makefiles and
PC makefiles compatible, i.e. one makefile is required for
each environment. wxGTK has its own configure system which can also
be used with wxMotif, although wxMotif has a simple makefile system of its own.

Sample makefiles for Unix (suffix .UNX), MS C++ (suffix .DOS and .NT), Borland
C++ (.BCC and .B32) and Symantec C++ (.SC) are included for the library, demos
and utilities.

The controlling makefile for wxWindows is in the platform-specific
directory, such as {\tt src/msw} or {\tt src/motif}.

Please see the platform-specific {\tt install.txt} file for further details.

\section{Windows-specific files}

wxWindows application compilation under MS Windows requires at least two
extra files, resource and module definition files.

\subsection{Resource file}\label{resources}

The least that must be defined in the Windows resource file (extension RC)
is the following statement:

\begin{verbatim}
rcinclude "wx/msw/wx.rc"
\end{verbatim}

which includes essential internal wxWindows definitions.  The resource script
may also contain references to icons, cursors, etc., for example:

\begin{verbatim}
wxicon icon wx.ico
\end{verbatim}

The icon can then be referenced by name when creating a frame icon. See
the MS Windows SDK documentation.

\normalbox{Note: include wx.rc {\it after} any ICON statements
so programs that search your executable for icons (such
as the Program Manager) find your application icon first.}

\subsection{Module definition file}

A module definition file (extension DEF) is required for 16-bit applications, and
looks like the following:

\begin{verbatim}
NAME         Hello
DESCRIPTION  'Hello'
EXETYPE      WINDOWS
STUB         'WINSTUB.EXE'
CODE         PRELOAD MOVEABLE DISCARDABLE
DATA         PRELOAD MOVEABLE MULTIPLE
HEAPSIZE     1024
STACKSIZE    8192
\end{verbatim}

The only lines which will usually have to be changed per application are
NAME and DESCRIPTION.

\subsection{Allocating and deleting wxWindows objects}

In general, classes derived from wxWindow must dynamically allocated
with {\it new} and deleted with {\it delete}. If you delete a window,
all of its children and descendants will be automatically deleted,
so you don't need to delete these descendants explicitly.

When deleting a frame or dialog, use {\bf Destroy} rather than {\bf delete} so
that the wxWindows delayed deletion can take effect. This waits until idle time
(when all messages have been processed) to actually delete the window, to avoid
problems associated with the GUI sending events to deleted windows.

Don't create a window on the stack, because this will interfere
with delayed deletion.

If you decide to allocate a C++ array of objects (such as wxBitmap) that may
be cleaned up by wxWindows, make sure you delete the array explicitly
before wxWindows has a chance to do so on exit, since calling {\it delete} on
array members will cause memory problems.

wxColour can be created statically: it is not automatically cleaned
up and is unlikely to be shared between other objects; it is lightweight
enough for copies to be made.

Beware of deleting objects such as a wxPen or wxBitmap if they are still in use.
Windows is particularly sensitive to this: so make sure you
make calls like wxDC::SetPen(wxNullPen) or wxDC::SelectObject(wxNullBitmap) before deleting
a drawing object that may be in use. Code that doesn't do this will probably work
fine on some platforms, and then fail under Windows.

\section{Conditional compilation}

One of the purposes of wxWindows is to reduce the need for conditional
compilation in source code, which can be messy and confusing to follow.
However, sometimes it is necessary to incorporate platform-specific
features (such as metafile use under MS Windows). The symbols
listed in the file {\tt symbols.txt} may be used for this purpose,
along with any user-supplied ones.

\section{C++ issues}

The following documents some miscellaneous C++ issues.

\subsection{Templates}

wxWindows does not use templates since it is a notoriously unportable feature.

\subsection{RTTI}

wxWindows does not use run-time type information since wxWindows provides
its own run-time type information system, implemented using macros.

\subsection{Type of NULL}

Some compilers (e.g. the native IRIX cc) define NULL to be 0L so that
no conversion to pointers is allowed. Because of that, all these
occurences of NULL in the GTK port use an explicit conversion such 
as

{\small
\begin{verbatim}
  wxWindow *my_window = (wxWindow*) NULL;
\end{verbatim}
}

It is recommended to adhere to this in all code using wxWindows as
this make the code (a bit) more portable.

\subsection{Precompiled headers}

Some compilers, such as Borland C++ and Microsoft C++, support
precompiled headers. This can save a great deal of compiling time. The
recommended approach is to precompile {\tt "wx.h"}, using this
precompiled header for compiling both wxWindows itself and any
wxWindows applications. For Windows compilers, two dummy source files
are provided (one for normal applications and one for creating DLLs)
to allow initial creation of the precompiled header.

However, there are several downsides to using precompiled headers. One
is that to take advantage of the facility, you often need to include
more header files than would normally be the case. This means that
changing a header file will cause more recompilations (in the case of
wxWindows, everything needs to be recompiled since everything includes {\tt "wx.h"}!)

A related problem is that for compilers that don't have precompiled
headers, including a lot of header files slows down compilation
considerably. For this reason, you will find (in the common
X and Windows parts of the library) conditional
compilation that under Unix, includes a minimal set of headers;
and when using Visual C++, includes {\tt wx.h}. This should help provide
the optimal compilation for each compiler, although it is
biassed towards the precompiled headers facility available
in Microsoft C++.

\section{File handling}

When building an application which may be used under different
environments, one difficulty is coping with documents which may be
moved to different directories on other machines. Saving a file which
has pointers to full pathnames is going to be inherently unportable. One
approach is to store filenames on their own, with no directory
information.  The application searches through a number of locally
defined directories to find the file. To support this, the class {\bf
wxPathList} makes adding directories and searching for files easy, and
the global function {\bf wxFileNameFromPath} allows the application to
strip off the filename from the path if the filename must be stored.
This has undesirable ramifications for people who have documents of the
same name in different directories.

As regards the limitations of DOS 8+3 single-case filenames versus
unrestricted Unix filenames, the best solution is to use DOS filenames
for your application, and also for document filenames {\it if} the user
is likely to be switching platforms regularly. Obviously this latter
choice is up to the application user to decide.  Some programs (such as
YACC and LEX) generate filenames incompatible with DOS; the best
solution here is to have your Unix makefile rename the generated files
to something more compatible before transferring the source to DOS.
Transferring DOS files to Unix is no problem, of course, apart from EOL
conversion for which there should be a utility available (such as
dos2unix).

See also the File Functions section of the reference manual for
descriptions of miscellaneous file handling functions.

\begin{comment}
\chapter{Utilities supplied with wxWindows}\label{utilities}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

A number of `extras' are supplied with wxWindows, to complement
the GUI functionality in the main class library. These are found
below the utils directory and usually have their own source, library
and documentation directories. For other user-contributed packages,
see the directory ftp://www.remstar.com/pub/wxwin/contrib, which is
more easily accessed via the Contributions page on the Web site.

\section{wxHelp}\label{wxhelp}

wxHelp is a stand-alone program, written using wxWindows,
for displaying hypertext help. It is necessary since not all target
systems (notably X) supply an adequate
standard for on-line help. wxHelp is modelled on the MS Windows help
system, with contents, search and browse buttons, but does not reformat
text to suit the size of window, as WinHelp does, and its input files
are uncompressed ASCII with some embedded font commands and an .xlp
extension. Most wxWindows documentation (user manuals and class
references) is supplied in wxHelp format, and also in Windows Help
format. The wxWindows 2.0 project will presently use an HTML widget
in a new and improved wxHelp implementation, under X.

Note that an application can be programmed to use Windows Help under
MS Windows, and wxHelp under X. An alternative help viewer under X is
Mosaic, a World Wide Web viewer that uses HTML as its native hypertext
format. However, this is not currently integrated with wxWindows
applications.

wxHelp works in two modes---edit and end-user. In edit mode, an ASCII
file may be marked up with different fonts and colours, and divided into
sections. In end-user mode, no editing is possible, and the user browses
principally by clicking on highlighted blocks.

When an application invokes wxHelp, subsequent sections, blocks or
files may be viewed using the same instance of wxHelp since the two
programs are linked using wxWindows interprocess communication
facilities. When the application exits, that application's instance of
wxHelp may be made to exit also.  See the {\bf wxHelpControllerBase} entry in the
reference section for how an application controls wxHelp.

\section{Tex2RTF}\label{textortf}

Supplied with wxWindows is a utility called Tex2RTF for converting\rtfsp
\LaTeX\ manuals to the following formats:

\begin{description}
\item[wxHelp]
wxWindows help system format (XLP).
\item[Linear RTF]
Rich Text Format suitable for importing into a word processor.
\item[Windows Help RTF]
Rich Text Format suitable for compiling into a WinHelp HLP file with the
help compiler.
\item[HTML]
HTML is the native format for Mosaic, the main hypertext viewer for
the World Wide Web. Since it is freely available it is a good candidate
for being the wxWindows help system under X, as an alternative to wxHelp.
\end{description}

Tex2RTF is used for the wxWindows manuals and can be used independently
by authors wishing to create on-line and printed manuals from the same\rtfsp
\LaTeX\ source.  Please see the separate documentation for Tex2RTF.

\section{wxTreeLayout}

This is a simple class library for drawing trees in a reasonably pretty
fashion. It provides only minimal default drawing capabilities, since
the algorithm is meant to be used for implementing custom tree-based
tools.

Directed graphs may also be drawn using this library, if cycles are
removed before the nodes and arcs are passed to the algorithm.

Tree displays are used in many applications: directory browsers,
hypertext systems, class browsers, and decision trees are a few
possibilities.

See the separate manual and the directory utils/wxtree.

\section{wxGraphLayout}

The wxGraphLayout class is based on a tool called `graphplace' by Dr.
Jos T.J. van Eijndhoven of Eindhoven University of Technology. Given a
(possibly cyclic) directed graph, it does its best to lay out the nodes
in a sensible manner. There are many applications (such as diagramming)
where it is required to display a graph with no human intervention. Even
if manual repositioning is later required, this algorithm can make a good
first attempt.

See the separate manual and the directory utils/wxgraph. 

\section{Colours}\label{coloursampler}

A colour sampler for viewing colours and their names on each
platform.

%
\chapter{Tutorial}\label{tutorial}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

To be written.
\end{comment}

\chapter{Programming strategies}\label{strategies}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter is intended to list strategies that may be useful when
writing and debugging wxWindows programs. If you have any good tips,
please submit them for inclusion here.

\section{Strategies for reducing programming errors}

\subsection{Use ASSERT}

Although I haven't done this myself within wxWindows, it is good
practice to use ASSERT statements liberally, that check for conditions that
should or should not hold, and print out appropriate error messages.
These can be compiled out of a non-debugging version of wxWindows
and your application. Using ASSERT is an example of `defensive programming':
it can alert you to problems later on.

\subsection{Use wxString in preference to character arrays}

Using wxString can be much safer and more convenient than using char *.
Again, I haven't practised what I'm preaching, but I'm now trying to use
wxString wherever possible. You can reduce the possibility of memory
leaks substantially, and it's much more convenient to use the overloaded
operators than functions such as strcmp. wxString won't add a significant
overhead to your program; the overhead is compensated for by easier
manipulation (which means less code).

The same goes for other data types: use classes wherever possible.

\section{Strategies for portability}

\subsection{Use relative positioning or constraints}

Don't use absolute panel item positioning if you can avoid it. Different GUIs have
very differently sized panel items. Consider using the constraint system, although this
can be complex to program.

Alternatively, you could use alternative .wrc (wxWindows resource files) on different
platforms, with slightly different dimensions in each. Or space your panel items out
to avoid problems.

\subsection{Use wxWindows resource files}

Use .wrc (wxWindows resource files) where possible, because they can be easily changed
independently of source code. Bitmap resources can be set up to load different
kinds of bitmap depending on platform (see the section on resource files).

\section{Strategies for debugging}\label{debugstrategies}

\subsection{Positive thinking}

It's common to blow up the problem in one's imagination, so that it seems to threaten
weeks, months or even years of work. The problem you face may seem insurmountable:
but almost never is. Once you have been programming for some time, you will be able
to remember similar incidents that threw you into the depths of despair. But
remember, you always solved the problem, somehow!

Perseverance is often the key, even though a seemingly trivial problem
can take an apparently inordinate amount of time to solve. In the end,
you will probably wonder why you worried so much. That's not to say it
isn't painful at the time. Try not to worry -- there are many more important
things in life.

\subsection{Simplify the problem}

Reduce the code exhibiting the problem to the smallest program possible
that exhibits the problem. If it is not possible to reduce a large and
complex program to a very small program, then try to ensure your code
doesn't hide the problem (you may have attempted to minimize the problem
in some way: but now you want to expose it).

With luck, you can add a small amount of code that causes the program
to go from functioning to non-functioning state. This should give a clue
to the problem. In some cases though, such as memory leaks or wrong
deallocation, this can still give totally spurious results!

\subsection{Use a debugger}

This sounds like facetious advice, but it's surprising how often people
don't use a debugger. Often it's an overhead to install or learn how to
use a debugger, but it really is essential for anything but the most
trivial programs.

\subsection{Use logging functions}

There is a variety of logging functions that you can use in your program:
see \helpref{Logging functions}{logfunctions}.

Using tracing statements may be more convenient than using the debugger
in some circumstances (such as when your debugger doesn't support a lot
of debugging code, or you wish to print a bunch of variables).

\subsection{Use the wxWindows debugging facilities}

You can use wxDebugContext to check for
memory leaks and corrupt memory: in fact in debugging mode, wxWindows will
automatically check for memory leaks at the end of the program if wxWindows is suitably
configured. Depending on the operating system and compiler, more or less
specific information about the problem will be logged.

You should also use \helpref{debug macros}{debugmacros} as part of a `defensive programming' strategy,
scattering wxASSERTs liberally to test for problems in your code as early as possible. Forward thinking
will save a surprising amount of time in the long run.

See the \helpref{debugging overview}{debuggingoverview} for further information.

\subsection{Check Windows debug messages}

Under Windows, it's worth running your program with DBWIN running or
some other program that shows Windows-generated debug messages. It's
possible it'll show invalid handles being used. You may have fun seeing
what commercial programs cause these normally hidden errors! Microsoft
recommend using the debugging version of Windows, which shows up even
more problems. However, I doubt it's worth the hassle for most
applications. wxWindows is designed to minimize the possibility of such
errors, but they can still happen occasionally, slipping through unnoticed
because they are not severe enough to cause a crash.

\subsection{Genetic mutation}

If we had sophisticated genetic algorithm tools that could be applied
to programming, we could use them. Until then, a common -- if rather irrational --
technique is to just make arbitrary changes to the code until something
different happens. You may have an intuition why a change will make a difference;
otherwise, just try altering the order of code, comment lines out, anything
to get over an impasse. Obviously, this is usually a last resort.

