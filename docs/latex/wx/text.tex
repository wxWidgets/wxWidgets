\section{\class{wxTextCtrl}}\label{wxtextctrl}

A text control allows text to be displayed and edited. It may be
single line or multi-line.

\wxheading{Derived from}

streambuf\\
\helpref{wxControl}{wxcontrol}\\
\helpref{wxWindow}{wxwindow}\\
\helpref{wxEvtHandler}{wxevthandler}\\
\helpref{wxObject}{wxobject}

\wxheading{Include files}

<wx/textctrl.h>

\wxheading{Window styles}

\twocolwidtha{5cm}
\begin{twocollist}\itemsep=0pt
\twocolitem{\windowstyle{wxTE\_PROCESS\_ENTER}}{The control will generate
the message wxEVENT\_TYPE\_TEXT\_ENTER\_COMMAND (otherwise pressing <Enter> is
either processed internally by the control or used for navigation between
dialog controls).}
\twocolitem{\windowstyle{wxTE\_PROCESS\_TAB}}{The control will receieve
EVT\_CHAR messages for TAB pressed - normally, TAB is used for passing to the
next control in a dialog instead. For the control created with this style,
you can still use Ctrl-Enter to pass to the next control from the keyboard.}
\twocolitem{\windowstyle{wxTE\_MULTILINE}}{The text control allows multiple lines.}
\twocolitem{\windowstyle{wxTE\_PASSWORD}}{The text will be echoed as asterisks.}
\twocolitem{\windowstyle{wxTE\_READONLY}}{The text will not be user-editable.}
\twocolitem{\windowstyle{wxHSCROLL}}{A horizontal scrollbar will be created.}
\end{twocollist}

See also \helpref{window styles overview}{windowstyles} and
\helpref{wxTextCtrl::wxTextCtrl}{wxtextctrlconstr}.

\wxheading{Remarks}

This class multiply-inherits from {\bf streambuf} where compilers allow, allowing code such as the following:

{\small%
\begin{verbatim}
  wxTextCtrl *control = new wxTextCtrl(...);

  ostream stream(control)

  stream << 123.456 << " some text\n";
  stream.flush();
\end{verbatim}
}%

If your compiler does not support derivation from {\bf streambuf} and gives a compile error, define the symbol {\bf NO\_TEXT\_WINDOW\_STREAM} in the
wxTextCtrl header file.

\wxheading{Event handling}

The following commands are processed by default event handlers in wxTextCtrl: wxID\_CUT, wxID\_COPY,
wxID\_PASTE, wxID\_UNDO, wxID\_REDO. The associated UI update events are also processed
automatically, when the control has the focus.

To process input from a text control, use these event handler macros to direct input to member
functions that take a \helpref{wxCommandEvent}{wxcommandevent} argument.

\twocolwidtha{7cm}%
\begin{twocollist}\itemsep=0pt
\twocolitem{{\bf EVT\_TEXT(id, func)}}{Respond to a wxEVT\_COMMAND\_TEXT\_UPDATED event,
generated when the text changes.}
\twocolitem{{\bf EVT\_TEXT\_ENTER(id, func)}}{Respond to a wxEVT\_COMMAND\_TEXT\_ENTER event,
generated when enter is pressed in a single-line text control.}
\end{twocollist}%

%\wxheading{See also}
%
%\helpref{wxRichTextCtrl}{wxrichtextctrl}
%
\latexignore{\rtfignore{\wxheading{Members}}}

\membersection{wxTextCtrl::wxTextCtrl}\label{wxtextctrlconstr}

\func{}{wxTextCtrl}{\void}

Default constructor.

\func{}{wxTextCtrl}{\param{wxWindow* }{parent}, \param{wxWindowID}{ id},\rtfsp
\param{const wxString\& }{value = ``"}, \param{const wxPoint\& }{pos}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = 0}, \param{const wxValidator\& }{validator}, \param{const wxString\& }{name = ``text"}}

Constructor, creating and showing a text control.

\wxheading{Parameters}

\docparam{parent}{Parent window. Should not be NULL.}

\docparam{id}{Control identifier. A value of -1 denotes a default value.}

\docparam{value}{Default text value.}

\docparam{pos}{Text control position.}

\docparam{size}{Text control size.}

\docparam{style}{Window style. See \helpref{wxTextCtrl}{wxtextctrl}.}

\docparam{validator}{Window validator.}

\docparam{name}{Window name.}

\wxheading{Remarks}

The horizontal scrollbar ({\bf wxTE\_HSCROLL} style flag) will only be created for multi-line text controls.
Without a horizontal scrollbar, text lines that don't fit in the control's
size will be wrapped (but no newline character is inserted). Single line
controls don't have a horizontal scrollbar, the text is automatically scrolled
so that the \helpref{insertion point}{wxtextctrlgetinsertionpoint} is always
visible.

Under Windows, if the {\bf wxTE\_MULTILINE} style is used, the window is implemented
as a Windows rich text control with unlimited capacity. Otherwise, normal edit control limits
apply.

\wxheading{See also}

\helpref{wxTextCtrl::Create}{wxtextctrlcreate}, \helpref{wxValidator}{wxvalidator}

\membersection{wxTextCtrl::\destruct{wxTextCtrl}}

\func{}{\destruct{wxTextCtrl}}{\void}

Destructor, destroying the text control.

\membersection{wxTextCtrl::AppendText}\label{wxtextctrlappendtext}

\func{void}{AppendText}{\param{const wxString\& }{ text}}

Appends the text to the end of the text control.

\wxheading{Parameters}

\docparam{text}{Text to write to the text control.}

\wxheading{Remarks}

After the text is appended, the insertion point will be at the end of the text control. If this behaviour is not desired,
the programmer should use \helpref{GetInsertionPoint}{wxtextctrlgetinsertionpoint} and \helpref{SetInsertionPoint}{wxtextctrlsetinsertionpoint}.

\wxheading{See also}

\helpref{wxTextCtrl::WriteText}{wxtextctrlwritetext}

\membersection{wxTextCtrl::CanCopy}\label{wxtextctrlcancopy}

\func{virtual bool}{CanCopy}{\void}

Returns TRUE if the selection can be copied to the clipboard.

\membersection{wxTextCtrl::CanCut}\label{wxtextctrlcancut}

\func{virtual bool}{CanCut}{\void}

Returns TRUE if the selection can be cut to the clipboard.

\membersection{wxTextCtrl::CanPaste}\label{wxtextctrlcanpaste}

\func{virtual bool}{CanPaste}{\void}

Returns TRUE if the contents of the clipboard can be pasted into the
text control. On some platforms (Motif, GTK) this is an approximation
and returns TRUE if the control is editable, FALSE otherwise.

\membersection{wxTextCtrl::CanRedo}\label{wxtextctrlcanredo}

\func{virtual bool}{CanRedo}{\void}

Returns TRUE if there is a redo facility available and the last operation
can be redone.

\membersection{wxTextCtrl::CanUndo}\label{wxtextctrlcanundo}

\func{virtual bool}{CanUndo}{\void}

Returns TRUE if there is an undo facility available and the last operation
can be undone.

\membersection{wxTextCtrl::Clear}\label{wxtextctrlclear}

\func{virtual void}{Clear}{\void}

Clears the text in the control.

\membersection{wxTextCtrl::Copy}\label{wxtextctrlcopy}

\func{virtual void}{Copy}{\void}

Copies the selected text to the clipboard under Motif and MS Windows.

\membersection{wxTextCtrl::Create}\label{wxtextctrlcreate}

\func{bool}{Create}{\param{wxWindow* }{parent}, \param{wxWindowID}{ id},\rtfsp
\param{const wxString\& }{value = ``"}, \param{const wxPoint\& }{pos}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = 0}, \param{const wxValidator\& }{validator}, \param{const wxString\& }{name = ``text"}}

Creates the text control for two-step construction. Derived classes
should call or replace this function. See \helpref{wxTextCtrl::wxTextCtrl}{wxtextctrlconstr}\rtfsp
for further details.

\membersection{wxTextCtrl::Cut}\label{wxtextctrlcut}

\func{virtual void}{Cut}{\void}

Copies the selected text to the clipboard and removes the selection.

\membersection{wxTextCtrl::DiscardEdits}

\func{void}{DiscardEdits}{\void}

Resets the internal `modified' flag as if the current edits had been saved.

\membersection{wxTextCtrl::GetInsertionPoint}\label{wxtextctrlgetinsertionpoint}

\constfunc{virtual long}{GetInsertionPoint}{\void}

Returns the insertion point. This is defined as the zero based index of the
character position to the right of the insertion point. For example, if
the insertion point is at the end of the text control, it is equal to
both \helpref{GetValue()}{wxtextctrlgetvalue}.Length() and
\helpref{GetLastPosition()}{wxtextctrlgetlastposition}.

The following code snippet safely returns the character at the insertion
point or the zero character if the point is at the end of the control.

{\small%
\begin{verbatim}
  char GetCurrentChar(wxTextCtrl *tc) {
    if (tc->GetInsertionPoint() == tc->GetLastPosition())
      return '\0';
    return tc->GetValue[tc->GetInsertionPoint()];
  }
\end{verbatim}
}%

\membersection{wxTextCtrl::GetLastPosition}\label{wxtextctrlgetlastposition}

\constfunc{virtual long}{GetLastPosition}{\void}

Returns the zero based index of the last position in the text control,
which is equal to the number of characters in the control.

\membersection{wxTextCtrl::GetLineLength}\label{wxtextctrlgetlinelength}

\constfunc{int}{GetLineLength}{\param{long}{ lineNo}}

Gets the length of the specified line, not including any trailing newline
character(s).

\wxheading{Parameters}

\docparam{lineNo}{Line number (starting from zero).}

\wxheading{Return value}

The length of the line, or -1 if {\it lineNo} was invalid.

\membersection{wxTextCtrl::GetLineText}\label{wxtextctrlgetlinetext}

\constfunc{wxString}{GetLineText}{\param{long}{ lineNo}}

Returns the contents of a given line in the text control, not including
any trailing newline character(s).

\wxheading{Parameters}

\docparam{lineNo}{The line number, starting from zero.}

\wxheading{Return value}

The contents of the line.

\membersection{wxTextCtrl::GetNumberOfLines}\label{wxtextctrlgetnumberoflines}

\constfunc{int}{GetNumberOfLines}{\void}

Returns the number of lines in the text control buffer.

\wxheading{Remarks}

Note that even empty text controls have one line (where the insertion point
is), so GetNumberOfLines() never returns 0.

For gtk\_text (multi-line) controls, the number of lines is
calculated by actually counting newline characters in the buffer. You
may wish to avoid using functions that work with line numbers if you are
working with controls that contain large amounts of text.

\membersection{wxTextCtrl::GetSelection}\label{wxtextctrlgetselection}

\func{virtual void}{GetSelection}{\param{long*}{ from}, \param{long*}{ to}}

Gets the current selection span. If the returned values are equal, there was
no selection.

\wxheading{Parameters}

\docparam{from}{The returned first position.}

\docparam{to}{The returned last position.}

\pythonnote{The wxPython version of this method returns a tuple
consisting of the from and to values.}

\membersection{wxTextCtrl::GetValue}\label{wxtextctrlgetvalue}

\constfunc{wxString}{GetValue}{\void}

Gets the contents of the control.

\membersection{wxTextCtrl::IsModified}\label{wxtextctrlismodified}

\constfunc{bool}{IsModified}{\void}

Returns TRUE if the text has been modified.

\membersection{wxTextCtrl::LoadFile}\label{wxtextctrlloadfile}

\func{bool}{LoadFile}{\param{const wxString\& }{ filename}}

Loads and displays the named file, if it exists.

\wxheading{Parameters}

\docparam{filename}{The filename of the file to load.}

\wxheading{Return value}

TRUE if successful, FALSE otherwise.

\membersection{wxTextCtrl::OnChar}\label{wxtextctrlonchar}

\func{void}{OnChar}{\param{wxKeyEvent\& }{event}}

Default handler for character input.

\wxheading{Remarks}

It is possible to intercept character
input by overriding this member. Call this function
to let the default behaviour take place; not calling
it results in the character being ignored. You can
replace the {\it keyCode} member of {\it event} to
translate keystrokes.

Note that Windows and Motif have different ways
of implementing the default behaviour. In Windows,
calling wxTextCtrl::OnChar immediately
processes the character. In Motif,
calling this function simply sets a flag
to let default processing happen. This might affect
the way in which you write your OnChar function
on different platforms.

\wxheading{See also}

\helpref{wxKeyEvent}{wxkeyevent}

\membersection{wxTextCtrl::OnDropFiles}\label{wxtextctrlondropfiles}

\func{void}{OnDropFiles}{\param{wxDropFilesEvent\& }{event}}

This event handler function implements default drag and drop behaviour, which
is to load the first dropped file into the control.

\wxheading{Parameters}

\docparam{event}{The drop files event.}

\wxheading{Remarks}

This is not yet implemented for the GTK.

\wxheading{See also}

\helpref{wxDropFilesEvent}{wxdropfilesevent}

\membersection{wxTextCtrl::Paste}\label{wxtextctrlpaste}

\func{virtual void}{Paste}{\void}

Pastes text from the clipboard to the text item.

\membersection{wxTextCtrl::PositionToXY}\label{wxtextctrlpositiontoxy}

\constfunc{long}{PositionToXY}{\param{long }{pos}, \param{long *}{x}, \param{long *}{y}}

Converts given position to a zero-based column, line number pair.

\wxheading{Parameters}

\docparam{pos}{Position.}

\docparam{x}{Receives zero based column number.}

\docparam{y}{Receives zero based line number.}

\wxheading{Return value}

Non-zero on success, zero on failure (most likely due to a too large position
parameter).

\wxheading{See also}

\helpref{wxTextCtrl::XYToPosition}{wxtextctrlxytoposition}

\pythonnote{In Python, PositionToXY() returns a tuple containing the x and
y values, so (x,y) = PositionToXY() is equivalent to the call described
above.}

\membersection{wxTextCtrl::Redo}\label{wxtextctrlredo}

\func{virtual void}{Redo}{\void}

If there is a redo facility and the last operation can be redone, redoes the last operation. Does nothing
if there is no redo facility.

\membersection{wxTextCtrl::Remove}\label{wxtextctrlremove}

\func{virtual void}{Remove}{\param{long}{ from}, \param{long}{ to}}

Removes the text starting at the first given position up to (but not including)
the character at the last position.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}

\membersection{wxTextCtrl::Replace}\label{wxtextctrlreplace}

\func{virtual void}{Replace}{\param{long}{ from}, \param{long}{ to}, \param{const wxString\& }{value}}

Replaces the text starting at the first position up to (but not including)
the character at the last position with the given text.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}

\docparam{value}{The value to replace the existing text with.}

\membersection{wxTextCtrl::SaveFile}\label{wxtextctrlsavefile}

\func{bool}{SaveFile}{\param{const wxString\& }{ filename}}

Saves the contents of the control in a text file.

\wxheading{Parameters}

\docparam{filename}{The name of the file in which to save the text.}

\wxheading{Return value}

TRUE if the operation was successful, FALSE otherwise.

\membersection{wxTextCtrl::SetEditable}\label{wxtextctrlseteditable}

\func{virtual void}{SetEditable}{\param{const bool}{ editable}}

Makes the text item editable or read-only, overriding the {\bf wxTE\_READONLY}
flag.

\wxheading{Parameters}

\docparam{editable}{If TRUE, the control is editable. If FALSE, the control is read-only.}

\membersection{wxTextCtrl::SetInsertionPoint}\label{wxtextctrlsetinsertionpoint}

\func{virtual void}{SetInsertionPoint}{\param{long}{ pos}}

Sets the insertion point at the given position.

\wxheading{Parameters}

\docparam{pos}{Position to set.}

\membersection{wxTextCtrl::SetInsertionPointEnd}\label{wxtextctrlsetinsertionpointend}

\func{virtual void}{SetInsertionPointEnd}{\void}

Sets the insertion point at the end of the text control. This is equivalent
to \helpref{SetInsertionPoint}{wxtextctrlsetinsertionpoint}(\helpref{GetLastPosition}{wxtextctrlgetlastposition}()).

\membersection{wxTextCtrl::SetSelection}\label{wxtextctrlsetselection}

\func{virtual void}{SetSelection}{\param{long}{ from}, \param{long}{ to}}

Selects the text starting at the first position up to (but not including) the character at the last position.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}

\membersection{wxTextCtrl::SetValue}\label{wxtextctrlsetvalue}

\func{virtual void}{SetValue}{\param{const wxString\& }{ value}}

Sets the text value.

\wxheading{Parameters}

\docparam{value}{The new value to set. It may contain newline characters if the text control is multi-line.}

\membersection{wxTextCtrl::ShowPosition}\label{wxtextctrlshowposition}

\func{void}{ShowPosition}{\param{long}{ pos}}

Makes the line containing the given position visible.

\wxheading{Parameters}

\docparam{pos}{The position that should be visible.}

\membersection{wxTextCtrl::Undo}\label{wxtextctrlundo}

\func{virtual void}{Undo}{\void}

If there is an undo facility and the last operation can be undone, undoes the last operation. Does nothing
if there is no undo facility.

\membersection{wxTextCtrl::WriteText}\label{wxtextctrlwritetext}

\func{void}{WriteText}{\param{const wxString\& }{ text}}

Writes the text into the text control at the current insertion position.

\wxheading{Parameters}

\docparam{text}{Text to write to the text control.}

\wxheading{Remarks}

Newlines in the text string
are the only control characters allowed, and they will cause appropriate
line breaks.  See \helpref{wxTextCtrl::\cinsert}{wxtextctrlinsert} and \helpref{wxTextCtrl::AppendText}{wxtextctrlappendtext} for more convenient ways of writing to the window.

After the write operation, the insertion point will be at the end of the inserted text, so subsequent write operations will be appended. To append text after the user may have interacted with the control, call \helpref{wxTextCtrl::SetInsertionPointEnd}{wxtextctrlsetinsertionpointend} before writing.

\membersection{wxTextCtrl::XYToPosition}\label{wxtextctrlxytoposition}

\func{long}{XYToPosition}{\param{long}{ x}, \param{long}{ y}}

Converts the given zero based column and line number to a position.

\wxheading{Parameters}

\docparam{x}{The column number.}

\docparam{y}{The line number.}

\wxheading{Return value}

The position value.

\membersection{wxTextCtrl::operator \cinsert}\label{wxtextctrlinsert}

\func{wxTextCtrl\&}{operator \cinsert}{\param{const wxString\& }{s}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{int}{ i}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{long}{ i}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{float}{ f}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{double}{ d}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{char}{ c}}

Operator definitions for appending to a text control, for example:

\begin{verbatim}
  wxTextCtrl *wnd = new wxTextCtrl(my_frame);

  (*wnd) << "Welcome to text control number " << 1 << ".\n";
\end{verbatim}

