%%%%%%%%%%%%%%%%%%%%%%%%%%%% wxTextCtrl %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\class{wxTextCtrl}}\label{wxtextctrl}

A text control allows text to be displayed and edited. It may be
single line or multi-line.

\wxheading{Derived from}

streambuf\\
\helpref{wxControl}{wxcontrol}\\
\helpref{wxWindow}{wxwindow}\\
\helpref{wxEvtHandler}{wxevthandler}\\
\helpref{wxObject}{wxobject}

\wxheading{Include files}

<wx/textctrl.h>

\wxheading{Window styles}

\twocolwidtha{5cm}
\begin{twocollist}\itemsep=0pt
\twocolitem{\windowstyle{wxTE\_PROCESS\_ENTER}}{The control will generate
the event wxEVT\_COMMAND\_TEXT\_ENTER (otherwise pressing Enter key
is either processed internally by the control or used for navigation between
dialog controls).}
\twocolitem{\windowstyle{wxTE\_PROCESS\_TAB}}{The control will receive
wxEVT\_CHAR events for TAB pressed - normally, TAB is used for passing to the
next control in a dialog instead. For the control created with this style,
you can still use Ctrl-Enter to pass to the next control from the keyboard.}
\twocolitem{\windowstyle{wxTE\_MULTILINE}}{The text control allows multiple lines.}
\twocolitem{\windowstyle{wxTE\_PASSWORD}}{The text will be echoed as asterisks.}
\twocolitem{\windowstyle{wxTE\_READONLY}}{The text will not be user-editable.}
\twocolitem{\windowstyle{wxTE\_RICH}}{Use rich text control under Win32, this
allows to have more than 64KB of text in the control even under Win9x. This
style is ignored under other platforms.}
\twocolitem{\windowstyle{wxTE\_RICH2}}{Use rich text control version 2.0 or 3.0
under Win32, this style is ignored under other platforms}
\twocolitem{\windowstyle{wxTE\_AUTO\_URL}}{Highlight the URLs and generate the
wxTextUrlEvents when mouse events occur over them. This style is only supported
for wxTE\_RICH Win32 and multi-line wxGTK2 text controls.}
\twocolitem{\windowstyle{wxTE\_NOHIDESEL}}{By default, the Windows text control
doesn't show the selection when it doesn't have focus - use this style to force
it to always show it. It doesn't do anything under other platforms.}
\twocolitem{\windowstyle{wxHSCROLL}}{A horizontal scrollbar will be created and
used, so that text won't be wrapped. No effect under wxGTK1.}
\twocolitem{\windowstyle{wxTE\_LEFT}}{The text in the control will be left-justified (default).}
\twocolitem{\windowstyle{wxTE\_CENTRE}}{The text in the control will be centered (currently wxMSW and wxGTK2 only).}
\twocolitem{\windowstyle{wxTE\_RIGHT}}{The text in the control will be right-justified (currently wxMSW and wxGTK2 only).}
\twocolitem{\windowstyle{wxTE\_DONTWRAP}}{Same as {\tt wxHSCROLL} style: don't wrap at all, show horizontal scrollbar instead.}
\twocolitem{\windowstyle{wxTE\_CHARWRAP}}{Wrap the lines too long to be shown entirely at any position (wxUniv and wxGTK2 only).}
\twocolitem{\windowstyle{wxTE\_WORDWRAP}}{Wrap the lines too long to be shown entirely at word boundaries (wxUniv and wxGTK2 only).}
\twocolitem{\windowstyle{wxTE\_BESTWRAP}}{Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default).}
\twocolitem{\windowstyle{wxTE\_CAPITALIZE}}{On PocketPC and Smartphone, causes the first letter to be capitalized.}
\end{twocollist}

See also \helpref{window styles overview}{windowstyles} and \helpref{wxTextCtrl::wxTextCtrl}{wxtextctrlctor}.

\wxheading{wxTextCtrl text format}

The multiline text controls always store the text as a sequence of lines
separated by {\tt $\backslash$n} characters, i.e. in the Unix text format even
on non-Unix platforms. This allows the user code to ignore the differences
between the platforms but at a price: the indices in the control such as those
returned by \helpref{GetInsertionPoint}{wxtextctrlgetinsertionpoint} or
\helpref{GetSelection}{wxtextctrlgetselection} can {\bf not} be used as
indices into the string returned by \helpref{GetValue}{wxtextctrlgetvalue} as
they're going to be slightly off for platforms using
{\tt $\backslash$r$\backslash$n} as separator (as Windows does), for example.

Instead, if you need to obtain a substring between the $2$ indices obtained
from the control with the help of the functions mentioned above, you should
use \helpref{GetRange}{wxtextctrlgetrange}. And the indices themselves can
only be passed to other methods, for example
\helpref{SetInsertionPoint}{wxtextctrlsetinsertionpoint} or
\helpref{SetSelection}{wxtextctrlsetselection}.

To summarize: never use the indices returned by (multiline) wxTextCtrl as
indices into the string it contains, but only as arguments to be passed back
to the other wxTextCtrl methods.

\wxheading{wxTextCtrl styles}

Multi-line text controls support the styles, i.e. provide a possibility to set
colours and font for individual characters in it (note that under Windows {\tt
wxTE\_RICH} style is required for style support). To use the styles you can
either call \helpref{SetDefaultStyle}{wxtextctrlsetdefaultstyle} before
inserting the text or call \helpref{SetStyle}{wxtextctrlsetstyle} later to
change the style of the text already in the control (the first solution is
much more efficient).

In either case, if the style doesn't specify some of the attributes (for
example you only want to set the text colour but without changing the font nor
the text background), the values of the default style will be used for them.
If there is no default style, the attributes of the text control itself are
used.

So the following code correctly describes what it does: the second call
to \helpref{SetDefaultStyle}{wxtextctrlsetdefaultstyle} doesn't change the
text foreground colour (which stays red) while the last one doesn't change the
background colour (which stays grey):

{\small%
\begin{verbatim}
    text->SetDefaultStyle(wxTextAttr(*wxRED));
    text->AppendText("Red text\n");
    text->SetDefaultStyle(wxTextAttr(wxNullColour, *wxLIGHT_GREY));
    text->AppendText("Red on grey text\n");
    text->SetDefaultStyle(wxTextAttr(*wxBLUE);
    text->AppendText("Blue on grey text\n");
\end{verbatim}
}%

\wxheading{wxTextCtrl and C++ streams}

This class multiply-inherits from {\bf streambuf} where compilers allow,
allowing code such as the following:

{\small%
\begin{verbatim}
  wxTextCtrl *control = new wxTextCtrl(...);

  ostream stream(control)

  stream << 123.456 << " some text\n";
  stream.flush();
\end{verbatim}
}%

If your compiler does not support derivation from {\bf streambuf} and gives a
compile error, define the symbol {\bf NO\_TEXT\_WINDOW\_STREAM} in the
wxTextCtrl header file.

Note that independently of this setting you can always use wxTextCtrl itself
in a stream-like manner:

{\small%
\begin{verbatim}
  wxTextCtrl *control = new wxTextCtrl(...);

  *control << 123.456 << " some text\n";
\end{verbatim}
}%

always works. However the possibility to create an ostream associated with
wxTextCtrl may be useful if you need to redirect the output of a function
taking an ostream as parameter to a text control.

Another commonly requested need is to redirect {\bf std::cout} to the text
control. This could be done in the following way:

{\small%
\begin{verbatim}
  #include <iostream>

  wxTextCtrl *control = new wxTextCtrl(...);

  std::streambuf *sbOld = std::cout.rdbuf();
  std::cout.rdbuf(*control);

  // use cout as usual, the output appears in the text control
  ...

  std::cout.rdbuf(sbOld);
\end{verbatim}
}%

But wxWidgets provides a convenient class to make it even simpler so instead
you may just do

{\small%
\begin{verbatim}
  #include <iostream>

  wxTextCtrl *control = new wxTextCtrl(...);

  wxStreamToTextRedirector redirect(control);

  // all output to cout goes into the text control until the exit from current
  // scope
\end{verbatim}
}%

See \helpref{wxStreamToTextRedirector}{wxstreamtotextredirector} for more
details.

\wxheading{Constants}

The values below are the possible return codes of the
\helpref{HitTest}{wxtextctrlhittest} method:

{\small
\begin{verbatim}
// the point asked is ...
enum wxTextCtrlHitTestResult
{
    wxTE_HT_UNKNOWN = -2,   // this means HitTest() is simply not implemented
    wxTE_HT_BEFORE,         // either to the left or upper
    wxTE_HT_ON_TEXT,        // directly on
    wxTE_HT_BELOW,          // below [the last line]
    wxTE_HT_BEYOND          // after [the end of line]
};
// ... the character returned
\end{verbatim}
}


\wxheading{Event handling}

The following commands are processed by default event handlers in wxTextCtrl: wxID\_CUT, wxID\_COPY,
wxID\_PASTE, wxID\_UNDO, wxID\_REDO. The associated UI update events are also processed
automatically, when the control has the focus.

To process input from a text control, use these event handler macros to direct input to member
functions that take a \helpref{wxCommandEvent}{wxcommandevent} argument.

\twocolwidtha{7cm}%
\begin{twocollist}\itemsep=0pt
\twocolitem{{\bf EVT\_TEXT(id, func)}}{Respond to a wxEVT\_COMMAND\_TEXT\_UPDATED event,
generated when the text changes. Notice that this event will be sent
when the text controls contents changes - whether this is due to user input or
comes from the program itself (for example, if SetValue() is called); see ChangeValue() for
a function which does not send this event.}
\twocolitem{{\bf EVT\_TEXT\_ENTER(id, func)}}{Respond to a wxEVT\_COMMAND\_TEXT\_ENTER event,
generated when enter is pressed in a text control (which must have
wxTE\_PROCESS\_ENTER style for this event to be generated).}
\twocolitem{{\bf EVT\_TEXT\_URL(id, func)}}{A mouse event occurred over an URL
in the text control (wxMSW and wxGTK2 only)}
\twocolitem{{\bf EVT\_TEXT\_MAXLEN(id, func)}}{User tried to enter more text
into the control than the limit set by
\helpref{SetMaxLength}{wxtextctrlsetmaxlength}.}
\end{twocollist}%

\latexignore{\rtfignore{\wxheading{Members}}}


\membersection{wxTextCtrl::wxTextCtrl}\label{wxtextctrlctor}

\func{}{wxTextCtrl}{\void}

Default constructor.

\func{}{wxTextCtrl}{\param{wxWindow* }{parent}, \param{wxWindowID}{ id},\rtfsp
\param{const wxString\& }{value = ``"}, \param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = 0}, \param{const wxValidator\& }{validator = wxDefaultValidator}, \param{const wxString\& }{name = wxTextCtrlNameStr}}

Constructor, creating and showing a text control.

\wxheading{Parameters}

\docparam{parent}{Parent window. Should not be NULL.}

\docparam{id}{Control identifier. A value of -1 denotes a default value.}

\docparam{value}{Default text value.}

\docparam{pos}{Text control position.}

\docparam{size}{Text control size.}

\docparam{style}{Window style. See \helpref{wxTextCtrl}{wxtextctrl}.}

\docparam{validator}{Window validator.}

\docparam{name}{Window name.}

\wxheading{Remarks}

The horizontal scrollbar ({\bf wxHSCROLL} style flag) will only be created
for multi-line text controls.
Without a horizontal scrollbar, text lines that don't fit in the control's
size will be wrapped (but no newline character is inserted). Single line
controls don't have a horizontal scrollbar, the text is automatically scrolled
so that the \helpref{insertion point}{wxtextctrlgetinsertionpoint} is always
visible.

% VZ: this is no longer true
%Under Windows, if the {\bf wxTE\_MULTILINE} style is used, the window is implemented
%as a Windows rich text control with unlimited capacity. Otherwise, normal edit control limits
%apply.

\wxheading{See also}

\helpref{wxTextCtrl::Create}{wxtextctrlcreate}, \helpref{wxValidator}{wxvalidator}


\membersection{wxTextCtrl::\destruct{wxTextCtrl}}\label{wxtextctrldtor}

\func{}{\destruct{wxTextCtrl}}{\void}

Destructor, destroying the text control.


\membersection{wxTextCtrl::AppendText}\label{wxtextctrlappendtext}

\func{void}{AppendText}{\param{const wxString\& }{ text}}

Appends the text to the end of the text control.

\wxheading{Parameters}

\docparam{text}{Text to write to the text control.}

\wxheading{Remarks}

After the text is appended, the insertion point will be at the end of the text control. If this behaviour is not desired,
the programmer should use \helpref{GetInsertionPoint}{wxtextctrlgetinsertionpoint} and \helpref{SetInsertionPoint}{wxtextctrlsetinsertionpoint}.

\wxheading{See also}

\helpref{wxTextCtrl::WriteText}{wxtextctrlwritetext}


\membersection{wxTextCtrl::CanCopy}\label{wxtextctrlcancopy}

\func{virtual bool}{CanCopy}{\void}

Returns {\tt true} if the selection can be copied to the clipboard.


\membersection{wxTextCtrl::CanCut}\label{wxtextctrlcancut}

\func{virtual bool}{CanCut}{\void}

Returns {\tt true} if the selection can be cut to the clipboard.


\membersection{wxTextCtrl::CanPaste}\label{wxtextctrlcanpaste}

\func{virtual bool}{CanPaste}{\void}

Returns {\tt true} if the contents of the clipboard can be pasted into the
text control. On some platforms (Motif, GTK) this is an approximation
and returns {\tt true} if the control is editable, {\tt false} otherwise.


\membersection{wxTextCtrl::CanRedo}\label{wxtextctrlcanredo}

\func{virtual bool}{CanRedo}{\void}

Returns {\tt true} if there is a redo facility available and the last operation
can be redone.


\membersection{wxTextCtrl::CanUndo}\label{wxtextctrlcanundo}

\func{virtual bool}{CanUndo}{\void}

Returns {\tt true} if there is an undo facility available and the last operation
can be undone.


\membersection{wxTextCtrl::Clear}\label{wxtextctrlclear}

\func{virtual void}{Clear}{\void}

Clears the text in the control.

Note that this function will generate a {\tt wxEVT\_COMMAND\_TEXT\_UPDATED}
event.


\membersection{wxTextCtrl::Copy}\label{wxtextctrlcopy}

\func{virtual void}{Copy}{\void}

Copies the selected text to the clipboard under Motif and MS Windows.


\membersection{wxTextCtrl::Create}\label{wxtextctrlcreate}

\func{bool}{Create}{\param{wxWindow* }{parent}, \param{wxWindowID}{ id},\rtfsp
\param{const wxString\& }{value = ``"}, \param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = 0}, \param{const wxValidator\& }{validator = wxDefaultValidator}, \param{const wxString\& }{name = wxTextCtrlNameStr}}

Creates the text control for two-step construction. Derived classes
should call or replace this function. See \helpref{wxTextCtrl::wxTextCtrl}{wxtextctrlctor}\rtfsp
for further details.


\membersection{wxTextCtrl::Cut}\label{wxtextctrlcut}

\func{virtual void}{Cut}{\void}

Copies the selected text to the clipboard and removes the selection.


\membersection{wxTextCtrl::DiscardEdits}\label{wxtextctrldiscardedits}

\func{void}{DiscardEdits}{\void}

Resets the internal `modified' flag as if the current edits had been saved.


\membersection{wxTextCtrl::EmulateKeyPress}\label{wxtextctrlemulatekeypress}

\func{bool}{EmulateKeyPress}{\param{const wxKeyEvent\& }{event}}

This functions inserts into the control the character which would have been
inserted if the given key event had occurred in the text control. The
{\it event} object should be the same as the one passed to {\tt EVT\_KEY\_DOWN}
handler previously by wxWidgets.

Please note that this function doesn't currently work correctly for all keys
under any platform but MSW.

\wxheading{Return value}

{\tt true} if the event resulted in a change to the control, {\tt false}
otherwise.


\membersection{wxTextCtrl::GetDefaultStyle}\label{wxtextctrlgetdefaultstyle}

\constfunc{const wxTextAttr\& }{GetDefaultStyle}{\void}

Returns the style currently used for the new text.

\wxheading{See also}

\helpref{SetDefaultStyle}{wxtextctrlsetdefaultstyle}


\membersection{wxTextCtrl::GetInsertionPoint}\label{wxtextctrlgetinsertionpoint}

\constfunc{virtual long}{GetInsertionPoint}{\void}

Returns the insertion point. This is defined as the zero based index of the
character position to the right of the insertion point. For example, if
the insertion point is at the end of the text control, it is equal to
both \helpref{GetValue()}{wxtextctrlgetvalue}.Length() and
\helpref{GetLastPosition()}{wxtextctrlgetlastposition}.

The following code snippet safely returns the character at the insertion
point or the zero character if the point is at the end of the control.

{\small%
\begin{verbatim}
  char GetCurrentChar(wxTextCtrl *tc) {
    if (tc->GetInsertionPoint() == tc->GetLastPosition())
      return '\0';
    return tc->GetValue[tc->GetInsertionPoint()];
  }
\end{verbatim}
}%


\membersection{wxTextCtrl::GetLastPosition}\label{wxtextctrlgetlastposition}

\constfunc{virtual wxTextPos}{GetLastPosition}{\void}

Returns the zero based index of the last position in the text control,
which is equal to the number of characters in the control.


\membersection{wxTextCtrl::GetLineLength}\label{wxtextctrlgetlinelength}

\constfunc{int}{GetLineLength}{\param{long}{ lineNo}}

Gets the length of the specified line, not including any trailing newline
character(s).

\wxheading{Parameters}

\docparam{lineNo}{Line number (starting from zero).}

\wxheading{Return value}

The length of the line, or -1 if {\it lineNo} was invalid.


\membersection{wxTextCtrl::GetLineText}\label{wxtextctrlgetlinetext}

\constfunc{wxString}{GetLineText}{\param{long}{ lineNo}}

Returns the contents of a given line in the text control, not including
any trailing newline character(s).

\wxheading{Parameters}

\docparam{lineNo}{The line number, starting from zero.}

\wxheading{Return value}

The contents of the line.


\membersection{wxTextCtrl::GetNumberOfLines}\label{wxtextctrlgetnumberoflines}

\constfunc{int}{GetNumberOfLines}{\void}

Returns the number of lines in the text control buffer.

\wxheading{Remarks}

Note that even empty text controls have one line (where the insertion point
is), so GetNumberOfLines() never returns $0$.

For wxGTK using GTK+ 1.2.x and earlier, the number of lines in a multi-line
text control is calculated by actually counting newline characters in the
buffer, i.e. this function returns the number of logical lines and doesn't
depend on whether any of them are wrapped. For all the other platforms, the
number of physical lines in the control is returned.

Also note that you may wish to avoid using functions that work with line
numbers if you are working with controls that contain large amounts of text as
this function has $O(N)$ complexity for $N$ being the number of lines.


\membersection{wxTextCtrl::GetRange}\label{wxtextctrlgetrange}

\constfunc{virtual wxString}{GetRange}{\param{long}{ from}, \param{long}{ to}}

Returns the string containing the text starting in the positions {\it from} and
up to {\it to} in the control. The positions must have been returned by another
wxTextCtrl method.

Please note that the positions in a multiline wxTextCtrl do {\bf not}
correspond to the indices in the string returned by
\helpref{GetValue}{wxtextctrlgetvalue} because of the different new line
representations ({\tt CR} or {\tt CR LF}) and so this method should be used to
obtain the correct results instead of extracting parts of the entire value. It
may also be more efficient, especially if the control contains a lot of data.


\membersection{wxTextCtrl::GetSelection}\label{wxtextctrlgetselection}

\constfunc{virtual void}{GetSelection}{\param{long*}{ from}, \param{long*}{ to}}

Gets the current selection span. If the returned values are equal, there was
no selection.

Please note that the indices returned may be used with the other wxTextctrl
methods but don't necessarily represent the correct indices into the string
returned by \helpref{GetValue()}{wxtextctrlgetvalue} for multiline controls
under Windows (at least,) you should use
\helpref{GetStringSelection()}{wxtextctrlgetstringselection} to get the selected
text.

\wxheading{Parameters}

\docparam{from}{The returned first position.}

\docparam{to}{The returned last position.}

\pythonnote{The wxPython version of this method returns a tuple
consisting of the from and to values.}

\perlnote{In wxPerl this method takes no parameter and returns a
2-element list {\tt ( from, to )}.}


\membersection{wxTextCtrl::GetStringSelection}\label{wxtextctrlgetstringselection}

\func{virtual wxString}{GetStringSelection}{\void}

Gets the text currently selected in the control. If there is no selection, the
returned string is empty.


\membersection{wxTextCtrl::GetStyle}\label{wxtextctrlgetstyle}

\func{bool}{GetStyle}{\param{long }{position}, \param{wxTextAttr\& }{style}}

Returns the style at this position in the text control. Not all platforms
support this function.

\wxheading{Return value}

{\tt true} on success, {\tt false} if an error occurred - it may also mean that
the styles are not supported under this platform.

\wxheading{See also}

\helpref{wxTextCtrl::SetStyle}{wxtextctrlsetstyle}, \helpref{wxTextAttr}{wxtextattr}


\membersection{wxTextCtrl::GetValue}\label{wxtextctrlgetvalue}

\constfunc{wxString}{GetValue}{\void}

Gets the contents of the control. Notice that for a multiline text control,
the lines will be separated by (Unix-style) $\backslash$n characters, even
under Windows where they are separated by a $\backslash$r$\backslash$n
sequence in the native control.


\membersection{wxTextCtrl::HitTest}\label{wxtextctrlhittest}

\constfunc{wxTextCtrlHitTestResult}{HitTest}{\param{const wxPoint\& }{pt}, \param{wxTextCoord }{*col}, \param{wxTextCoord }{*row}}

This function finds the character at the specified position expressed in
pixels. If the return code is not \texttt{wxTE\_HT\_UNKNOWN} the row and column
of the character closest to this position are returned in the \arg{col} and
\arg{row} parameters (unless the pointers are {\tt NULL} which is allowed).

Please note that this function is currently only implemented in wxUniv,
wxMSW and wxGTK2 ports.

\wxheading{See also}

\helpref{PositionToXY}{wxtextctrlpositiontoxy}, \helpref{XYToPosition}{wxtextctrlxytoposition}

\perlnote{In wxPerl this function takes only the position argument and
returns a 3-element list \texttt{(result, col, row)}}.


\membersection{wxTextCtrl::IsEditable}\label{wxtextctrliseditable}

\constfunc{bool}{IsEditable}{\void}

Returns {\tt true} if the controls contents may be edited by user (note that it
always can be changed by the program), i.e. if the control hasn't been put in
read-only mode by a previous call to
\helpref{SetEditable}{wxtextctrlseteditable}.


\membersection{wxTextCtrl::IsEmpty}\label{wxtextctrlisempty}

\constfunc{bool}{IsEmpty}{\void}

Returns \true if the control is currently empty. This is the same as 
\texttt{GetValue().empty()} but can be much more efficient for the multiline
controls containing big amounts of text.

\newsince{2.7.1}


\membersection{wxTextCtrl::IsModified}\label{wxtextctrlismodified}

\constfunc{bool}{IsModified}{\void}

Returns {\tt true} if the text has been modified by user. Note that calling
\helpref{SetValue}{wxtextctrlsetvalue} doesn't make the control modified.

\wxheading{See also}

\helpref{MarkDirty}{wxtextctrlmarkdirty}


\membersection{wxTextCtrl::IsMultiLine}\label{wxtextctrlismultiline}

\constfunc{bool}{IsMultiLine}{\void}

Returns {\tt true} if this is a multi line edit control and {\tt false}
otherwise.

\wxheading{See also}

\helpref{IsSingleLine}{wxtextctrlissingleline}


\membersection{wxTextCtrl::IsSingleLine}\label{wxtextctrlissingleline}

\constfunc{bool}{IsSingleLine}{\void}

Returns {\tt true} if this is a single line edit control and {\tt false}
otherwise.

\wxheading{See also}

\helpref{IsMultiLine}{wxtextctrlissingleline}


\membersection{wxTextCtrl::LoadFile}\label{wxtextctrlloadfile}

\func{bool}{LoadFile}{\param{const wxString\& }{ filename}, \param{int }{fileType = wxTEXT\_TYPE\_ANY}}

Loads and displays the named file, if it exists.

\wxheading{Parameters}

\docparam{filename}{The filename of the file to load.}

\docparam{fileType}{The type of file to load. This is currently ignored in wxTextCtrl.}

\wxheading{Return value}

{\tt true} if successful, {\tt false} otherwise.

% VZ: commenting this out as: (a) the docs are wrong (you can't replace
%     anything), (b) wxTextCtrl doesn't have any OnChar() anyhow
%% \membersection{wxTextCtrl::OnChar}\label{wxtextctrlonchar}
%%
%% \func{void}{OnChar}{\param{wxKeyEvent\& }{event}}
%%
%% Default handler for character input.
%%
%% \wxheading{Remarks}
%%
%% It is possible to intercept character
%% input by overriding this member. Call this function
%% to let the default behaviour take place; not calling
%% it results in the character being ignored. You can
%% replace the {\it keyCode} member of {\it event} to
%% translate keystrokes.
%%
%% Note that Windows and Motif have different ways
%% of implementing the default behaviour. In Windows,
%% calling wxTextCtrl::OnChar immediately
%% processes the character. In Motif,
%% calling this function simply sets a flag
%% to let default processing happen. This might affect
%% the way in which you write your OnChar function
%% on different platforms.
%%
%% \wxheading{See also}
%%
%% \helpref{wxKeyEvent}{wxkeyevent}


\membersection{wxTextCtrl::MarkDirty}\label{wxtextctrlmarkdirty}

\func{void}{MarkDirty}{\void}

Mark text as modified (dirty).

\wxheading{See also}

\helpref{IsModified}{wxtextctrlismodified}


\membersection{wxTextCtrl::OnDropFiles}\label{wxtextctrlondropfiles}

\func{void}{OnDropFiles}{\param{wxDropFilesEvent\& }{event}}

This event handler function implements default drag and drop behaviour, which
is to load the first dropped file into the control.

\wxheading{Parameters}

\docparam{event}{The drop files event.}

\wxheading{Remarks}

This is not implemented on non-Windows platforms.

\wxheading{See also}

\helpref{wxDropFilesEvent}{wxdropfilesevent}


\membersection{wxTextCtrl::Paste}\label{wxtextctrlpaste}

\func{virtual void}{Paste}{\void}

Pastes text from the clipboard to the text item.


\membersection{wxTextCtrl::PositionToXY}\label{wxtextctrlpositiontoxy}

\constfunc{bool}{PositionToXY}{\param{long }{pos}, \param{long *}{x}, \param{long *}{y}}

Converts given position to a zero-based column, line number pair.

\wxheading{Parameters}

\docparam{pos}{Position.}

\docparam{x}{Receives zero based column number.}

\docparam{y}{Receives zero based line number.}

\wxheading{Return value}

{\tt true} on success, {\tt false} on failure (most likely due to a too large position
parameter).

\wxheading{See also}

\helpref{wxTextCtrl::XYToPosition}{wxtextctrlxytoposition}

\pythonnote{In Python, PositionToXY() returns a tuple containing the x and
y values, so (x,y) = PositionToXY() is equivalent to the call described
above.}

\perlnote{In wxPerl this method only takes the {\tt pos} parameter, and
returns a 2-element list {\tt ( x, y )}.}


\membersection{wxTextCtrl::Redo}\label{wxtextctrlredo}

\func{virtual void}{Redo}{\void}

If there is a redo facility and the last operation can be redone, redoes the last operation. Does nothing
if there is no redo facility.


\membersection{wxTextCtrl::Remove}\label{wxtextctrlremove}

\func{virtual void}{Remove}{\param{long}{ from}, \param{long}{ to}}

Removes the text starting at the first given position up to (but not including)
the character at the last position.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}


\membersection{wxTextCtrl::Replace}\label{wxtextctrlreplace}

\func{virtual void}{Replace}{\param{long}{ from}, \param{long}{ to}, \param{const wxString\& }{value}}

Replaces the text starting at the first position up to (but not including)
the character at the last position with the given text.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}

\docparam{value}{The value to replace the existing text with.}


\membersection{wxTextCtrl::SaveFile}\label{wxtextctrlsavefile}

\func{bool}{SaveFile}{\param{const wxString\& }{ filename}, \param{int }{fileType = wxTEXT\_TYPE\_ANY}}

Saves the contents of the control in a text file.

\wxheading{Parameters}

\docparam{filename}{The name of the file in which to save the text.}

\docparam{fileType}{The type of file to save. This is currently ignored in wxTextCtrl.}

\wxheading{Return value}

{\tt true} if the operation was successful, {\tt false} otherwise.


\membersection{wxTextCtrl::SetDefaultStyle}\label{wxtextctrlsetdefaultstyle}

\func{bool}{SetDefaultStyle}{\param{const wxTextAttr\& }{style}}

Changes the default style to use for the new text which is going to be added
to the control using \helpref{WriteText}{wxtextctrlwritetext} or\rtfsp
\helpref{AppendText}{wxtextctrlappendtext}.

If either of the font, foreground, or background colour is not set in\rtfsp
{\it style}, the values of the previous default style are used for them. If
the previous default style didn't set them neither, the global font or colours
of the text control itself are used as fall back.

However if the {\it style} parameter is the default wxTextAttr, then the
default style is just reset (instead of being combined with the new style which
wouldn't change it at all).

\wxheading{Parameters}

\docparam{style}{The style for the new text.}

\wxheading{Return value}

{\tt true} on success, {\tt false} if an error occurred - may also mean that
the styles are not supported under this platform.

\wxheading{See also}

\helpref{GetDefaultStyle}{wxtextctrlgetdefaultstyle}


\membersection{wxTextCtrl::SetEditable}\label{wxtextctrlseteditable}

\func{virtual void}{SetEditable}{\param{const bool}{ editable}}

Makes the text item editable or read-only, overriding the {\bf wxTE\_READONLY} flag.

\wxheading{Parameters}

\docparam{editable}{If {\tt true}, the control is editable. If {\tt false}, the control is read-only.}

\wxheading{See also}

\helpref{IsEditable}{wxtextctrliseditable}


\membersection{wxTextCtrl::SetInsertionPoint}\label{wxtextctrlsetinsertionpoint}

\func{virtual void}{SetInsertionPoint}{\param{long}{ pos}}

Sets the insertion point at the given position.

\wxheading{Parameters}

\docparam{pos}{Position to set.}


\membersection{wxTextCtrl::SetInsertionPointEnd}\label{wxtextctrlsetinsertionpointend}

\func{virtual void}{SetInsertionPointEnd}{\void}

Sets the insertion point at the end of the text control. This is equivalent
to \helpref{SetInsertionPoint}{wxtextctrlsetinsertionpoint}(\helpref{GetLastPosition}{wxtextctrlgetlastposition}()).


\membersection{wxTextCtrl::SetMaxLength}\label{wxtextctrlsetmaxlength}

\func{virtual void}{SetMaxLength}{\param{unsigned long }{len}}

This function sets the maximum number of characters the user can enter into the
control. In other words, it allows to limit the text value length to {\it len}
not counting the terminating {\tt NUL} character.

If {\it len} is $0$, the previously set max length limit, if any, is discarded
and the user may enter as much text as the underlying native text control
widget supports (typically at least 32Kb).

If the user tries to enter more characters into the text control when it
already is filled up to the maximal length, a
{\tt wxEVT\_COMMAND\_TEXT\_MAXLEN} event is sent to notify the program about it
(giving it the possibility to show an explanatory message, for example) and the
extra input is discarded.

Note that under GTK+, this function may only be used with single line text controls.

\wxheading{Compatibility}

Only implemented in wxMSW/wxGTK starting with wxWidgets 2.3.2.


\membersection{wxTextCtrl::SetModified}\label{wxtextctrlsetmodified}

\func{void}{SetModified}{\param{bool }{modified}}

Marks the control as being modified by the user or not.

\wxheading{See also}

\helpref{MarkDirty}{wxtextctrlmarkdirty}, \helpref{DiscardEdits}{wxtextctrldiscardedits}


\membersection{wxTextCtrl::SetSelection}\label{wxtextctrlsetselection}

\func{virtual void}{SetSelection}{\param{long}{ from}, \param{long}{ to}}

Selects the text starting at the first position up to (but not including) the
character at the last position. If both parameters are equal to $-1$ all text
in the control is selected.

\wxheading{Parameters}

\docparam{from}{The first position.}

\docparam{to}{The last position.}


\membersection{wxTextCtrl::SetStyle}\label{wxtextctrlsetstyle}

\func{bool}{SetStyle}{\param{long }{start}, \param{long }{end}, \param{const wxTextAttr\& }{style}}

Changes the style of the given range. If any attribute within {\it style} is
not set, the corresponding attribute from \helpref{GetDefaultStyle()}{wxtextctrlgetdefaultstyle} is used.

\wxheading{Parameters}

\docparam{start}{The start of the range to change.}

\docparam{end}{The end of the range to change.}

\docparam{style}{The new style for the range.}

\wxheading{Return value}

{\tt true} on success, {\tt false} if an error occurred - it may also mean that
the styles are not supported under this platform.

\wxheading{See also}

\helpref{wxTextCtrl::GetStyle}{wxtextctrlgetstyle}, \helpref{wxTextAttr}{wxtextattr}


\membersection{wxTextCtrl::SetValue}\label{wxtextctrlsetvalue}

\func{virtual void}{SetValue}{\param{const wxString\& }{ value}}

Sets the text value and marks the control as not-modified (which means that
\helpref{IsModified}{wxtextctrlismodified} would return {\tt false} immediately
after the call to SetValue).

Note that this function will generate a {\tt wxEVT\_COMMAND\_TEXT\_UPDATED}
event.

This function is deprecated and should not be used in new code. Please use the
\helpref{ChangeValue}{wxtextctrlchangevalue} function instead.

\wxheading{Parameters}

\docparam{value}{The new value to set. It may contain newline characters if the text control is multi-line.}


\membersection{wxTextCtrl::ChangeValue}\label{wxtextctrlchangevalue}

\func{virtual void}{ChangeValue}{\param{const wxString\& }{ value}}

Sets the text value and marks the control as not-modified (which means that
\helpref{IsModified}{wxtextctrlismodified} would return {\tt false} immediately
after the call to SetValue).

Note that this function will \emph{not} generate the {\tt wxEVT\_COMMAND\_TEXT\_UPDATED} 
event.
This is the only difference with \helpref{SetValue}{wxtextctrlsetvalue}.
See \helpref{this topic}{progevent} for more info.

\wxheading{Parameters}

\docparam{value}{The new value to set. It may contain newline characters if the text control is multi-line.}


\membersection{wxTextCtrl::ShowPosition}\label{wxtextctrlshowposition}

\func{void}{ShowPosition}{\param{long}{ pos}}

Makes the line containing the given position visible.

\wxheading{Parameters}

\docparam{pos}{The position that should be visible.}


\membersection{wxTextCtrl::Undo}\label{wxtextctrlundo}

\func{virtual void}{Undo}{\void}

If there is an undo facility and the last operation can be undone, undoes the last operation. Does nothing
if there is no undo facility.


\membersection{wxTextCtrl::WriteText}\label{wxtextctrlwritetext}

\func{void}{WriteText}{\param{const wxString\& }{ text}}

Writes the text into the text control at the current insertion position.

\wxheading{Parameters}

\docparam{text}{Text to write to the text control.}

\wxheading{Remarks}

Newlines in the text string
are the only control characters allowed, and they will cause appropriate
line breaks.  See \helpref{wxTextCtrl::\cinsert}{wxtextctrlinsert} and \helpref{wxTextCtrl::AppendText}{wxtextctrlappendtext} for more convenient ways of writing to the window.

After the write operation, the insertion point will be at the end of the inserted text, so subsequent write operations will be appended. To append text after the user may have interacted with the control, call \helpref{wxTextCtrl::SetInsertionPointEnd}{wxtextctrlsetinsertionpointend} before writing.


\membersection{wxTextCtrl::XYToPosition}\label{wxtextctrlxytoposition}

\func{long}{XYToPosition}{\param{long}{ x}, \param{long}{ y}}

Converts the given zero based column and line number to a position.

\wxheading{Parameters}

\docparam{x}{The column number.}

\docparam{y}{The line number.}

\wxheading{Return value}

The position value, or -1 if {\tt x} or {\tt y} was invalid.


\membersection{wxTextCtrl::operator \cinsert}\label{wxtextctrlinsert}

\func{wxTextCtrl\&}{operator \cinsert}{\param{const wxString\& }{s}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{int}{ i}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{long}{ i}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{float}{ f}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{double}{ d}}

\func{wxTextCtrl\&}{operator \cinsert}{\param{char}{ c}}

Operator definitions for appending to a text control, for example:

\begin{verbatim}
  wxTextCtrl *wnd = new wxTextCtrl(my_frame);

  (*wnd) << "Welcome to text control number " << 1 << ".\n";
\end{verbatim}

