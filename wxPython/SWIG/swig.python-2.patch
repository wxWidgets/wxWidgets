Index: Doc/Manual/Python.html
===================================================================
RCS file: /cvsroot/swig/SWIG/Doc/Manual/Python.html,v
retrieving revision 1.18
diff -u -4 -r1.18 Python.html
--- Doc/Manual/Python.html	2 Sep 2004 20:27:14 -0000	1.18
+++ Doc/Manual/Python.html	23 Sep 2004 00:31:44 -0000
@@ -86,8 +86,15 @@
 <li><a href="#Python_nn62">Mapping Python tuples into small arrays</a>
 <li><a href="#Python_nn63">Mapping sequences to C arrays</a>
 <li><a href="#Python_nn64">Pointer handling</a>
 </ul>
+<li><a href="#Python_nn65">Docstring Features</a>
+<ul>
+<li><a href="#Python_nn66">Module docstring</a>
+<li><a href="#Python_nn67">%feature("autodoc")</a>
+<li><a href="#Python_nn68">%feature("docstring")</a>
+</ul>
+<li><a href="#Python_nn70">Python Packages</a>
 </ul>
 <!-- INDEX -->
 
 
@@ -2460,9 +2467,8 @@
 customization features as covered in later sections.
 
 <H3><a name="Python_nn42"></a>26.6.2 Adding additional Python code</H3>
 
-
 If writing support code in C isn't enough, it is also possible to write code in
 Python.  This code gets inserted in to the <tt>.py</tt> file created by SWIG.   One
 use of Python code might be to supply a high-level interface to certain functions.
 For example:
@@ -2506,8 +2512,46 @@
 soon enough.  For now, think of this example as an illustration of
 what can be done without having to rely on any of the more advanced
 customization features.
 
+<p>Sometimes you may want to replace or modify the wrapper function
+that SWIG creates in the proxy <tt>.py</tt> file.  The Python module
+in SWIG provides some features that enable you do do this.  First, to
+entirely replace a proxy function you can use
+<tt>%feature("shadow")</tt>.  For example:
+
+<blockquote>
+<pre>
+%module example
+%rename(bar_id) bar(int,double);
+
+// Rewrite bar() to allow some nice overloading
+
+%feature("shadow") Foo::bar(int) %{
+def bar(*args):
+    if len(args) == 3:
+         return apply(examplec.Foo_bar_id,args)
+    return apply(examplec.Foo_bar,args)
+%}
+    
+class Foo {
+public:
+    int bar(int x);
+    int bar(int x, double y);
+}
+</pre>
+</blockquote>
+
+
+Often the proxy function created by SWIG is fine, but you simply want
+to add code to it without touching the rest of the generated function
+body.  For these cases SWIG provides the "pythonprepend" and
+"pythonappend" features which do exactly as their names suggest.  The
+"pythonprepend" feature will insert its value at the begining of the
+proxy function, and "pythonappend" will insert code at the end of the
+proxy, just before the return statement.
+
+
 <H3><a name="Python_nn43"></a>26.6.3 Class extension with %extend</H3>
 
 
 One of the more interesting features of SWIG is that it can extend
@@ -3852,6 +3896,197 @@
 that has a <tt>this</tt> attribute.  In addition,
 <tt>SWIG_NewPointerObj()</tt> can automatically generate a proxy
 class object (if applicable).
 
+
+
+<H2><a name="Python_nn65"></a>26.10 Docstring Features</H2>
+
+Usign docstrings in Python code is becoming more and more important
+ans more tools are coming on the scene that take advantage of them,
+everything from full-blown documentaiton generators to class browsers
+and popup call-tips in Python-aware IDEs.  Given the way that SWIG
+generates the proxy code by default, your users will normally get
+something like <tt>"function_name(*args)"</tt> in the popup calltip of
+their IDE which is next to useless when the real function prototype
+might be something like this:
+
+<blockquote>
+<pre>
+bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
+</pre>
+</blockquote>
+
+The features described in this section make it easy for you to add
+docstrings to your modules, functions and methods that can then be
+used by the various tools out there to make the programming experience
+of your users much simpler.
+
+
+<H3><a name="Python_nn66"></a>26.10.1 Module docstring</H3>
+
+Python allows a docstring at the begining of the <tt>.py</tt> file
+before any other statements, and it is typically used to give a
+general description of the entire module.  SWIG supports this by
+setting an option of the <tt>%module</tt> directive.  For example:
+
+<blockquote>
+<pre>
+%module(docstring="This is the example module's docstring") example
+</pre>
+</blockquote>
+
+When you have more than just a line or so then you can retain the easy
+readability of the <tt>%module</tt> directive by using a macro.  For
+example:
+
+<blockquote>
+<pre>
+%define DOCSTRING
+"The `XmlResource` class allows program resources defining menus, 
+layout of controls on a panel, etc. to be loaded from an XML file."
+%enddef
+
+%module(docstring=DOCSTRING) xrc
+</pre>
+</blockquote>
+
+
+<H3><a name="Python_nn67"></a>26.10.2 %feature("autodoc")</H3>
+
+As alluded to above SWIG will generate all the function and method
+proxy wrappers with just "*args" (or "*args, **kwargs" if the -keyword
+option is used) for a parameter list and will then sort out the
+individual parameters in the C wrapper code.  This is nice and simple
+for the wrapper code, but makes it difficult to be programmer and tool
+friendly as anyone looking at the <tt>.py</tt> file will not be able
+to find out anything about the parameters that the fuctions accept.
+
+<p>But since SWIG does know everything about the fucntion it is
+possible to generate a docstring containing the parameter types, names
+and default values. Since many of the doctring tools are adopting a
+standard of recognizing if the first thing in the docstring is a
+function prototype then using that instead of what they found from
+introspeciton, then life is good once more.
+
+<p>SWIG's Python module provides support for the "autodoc" feature,
+which when attached to a node in the parse tree will cause a docstring
+to be generated that includes the name of the funciton, parameter
+names, default values if any, and return type if any. There are also
+three options for autodoc controlled by the value given to the
+feature, described below.
+
+<H4>%feature("autodoc", "0")</H4>
+
+When the "0" option is given then the types of the parameters will
+<em>not</em> be included in the autodoc string.  For example, given
+this function prototype:
+
+<blockquote>
+<pre>
+%feature("autodoc", "0");
+bool function_name(int x, int y, Foo* foo=NULL, Bar* bar=NULL);
+</pre>
+</blockquote>
+
+Then Python code like this will be generated:
+
+<blockquote>
+<pre>
+def function_name(*args, **kwargs):
+    """function_name(x, y, foo=None, bar=None) -> bool"""
+    ...
+</pre>
+</blockquote>
+
+
+<H4>%feature("autodoc", "1")</H4>
+
+When the "1" option is used then the parameter types <em>will</em> be
+used in the autodoc string.  In addition, an atempt is made to
+simplify the type name such that it makes more sense to the Python
+user.  Pointer, reference and const info is removed,
+<tt>%rename</tt>'s are evaluated, etc.  (This is not always
+successful, but works most of the time.  See the next section for what
+to do when it doesn't.)  Given the example above, then turning on the
+parameter types with the "1" option will result in Python code like
+this:
+
+<blockquote>
+<pre>
+def function_name(*args, **kwargs):
+    """function_name(int x, int y, Foo foo=None, Bar bar=None) -> bool"""
+    ...
+</pre>
+</blockquote>
+
+
+
+<H4>%feature("autodoc", "docstring")</H4>
+
+Finally, there are times when the automatically generated autodoc
+string will make no sense for a Python programmer, particularly when a
+typemap is involved.  So if you give an explicit value for the autodoc
+feature then that string will be used in place of the automatically
+generated string.  For example:
+
+<blockquote>
+<pre>
+%feature("autodoc", "GetPosition() -> (x, y)") GetPosition;
+void GetPosition(int* OUTPUT, int* OUTPUT);
+</pre>
+</blockquote>
+
+
+<H3><a name="Python_nn68"></a>26.10.3 %feature("docstring")</H3>
+
+In addition to the autodoc strings described above, you can also
+attach any arbitrary descriptive text to a node in the parse tree with
+the "docstring" feature.  When the proxy module is generated then any
+docstring associated with classes, function or methods are output.
+If an item already has an autodoc string then it is combined with the
+docstring and they are output together.  If the docstring is all on a
+single line then it is output like this::
+
+<blockquote>
+<pre>
+"""This is the docstring"""
+</pre>
+</blockquote>
+
+Otherwise, to aid readability it is output like this:
+
+<blockquote>
+<pre>
+"""
+This is a multi-line docstring
+with more than one line.
+"""
+</pre>
+</blockquote>
+
+<H2><a name="Python_nn70"></a>26.11 Python Packages</H2>
+
+Using the <tt>package</tt> option of the <tt>%module</tt> directive
+allows you to specify what Python package that the module will be
+living in when installed. 
+
+<blockquote>
+<pre>
+%module(package="wx") xrc
+</pre>
+</blockquote>
+
+This is useful when the <tt>.i</tt> file is <tt>%import</tt>ed by
+another <tt>.i</tt> file.  By default SWIG will assume that the
+importer is able to find the importee with just the module name, but
+if they live in separate Python packages then that won't work.
+However if the importee specifies what its package is with the
+<tt>%module</tt> option then the Python code generated for the
+importer will use that package name when importing the other module
+and also in base class declarations, etc. if the pacakge name is
+different than its own.
+
+
+
 </body>
 </html>
Index: Source/Modules/python.cxx
===================================================================
RCS file: /cvsroot/swig/SWIG/Source/Modules/python.cxx,v
retrieving revision 1.50
diff -u -4 -r1.50 python.cxx
--- Source/Modules/python.cxx	1 Sep 2004 22:25:56 -0000	1.50
+++ Source/Modules/python.cxx	23 Sep 2004 00:31:44 -0000
@@ -19,8 +19,9 @@
 
 static  String       *const_code = 0;
 static  String       *shadow_methods = 0;
 static  String       *module = 0;
+static  String       *package = 0;
 static  String       *mainmodule = 0;
 static  String       *interface = 0;
 static  String       *global_name = 0;
 static  int           shadow = 1;
@@ -50,8 +51,18 @@
 static  int       have_constructor;
 static  int       have_repr;
 static  String   *real_classname;
 
+/* flags for the make_autodoc function */
+enum autodoc_t {
+  AUTODOC_CLASS,
+  AUTODOC_CTOR,
+  AUTODOC_DTOR,
+  AUTODOC_STATICFUNC,
+  AUTODOC_FUNC,
+  AUTODOC_METHOD
+};
+
 static const char *usage = (char *)"\
 Python Options (available with -python)\n\
      -globals <name> - Set <name> used to access C global variable [default: 'cvar']\n\
      -interface <lib>- Set the lib name to <lib>\n\
@@ -145,19 +156,22 @@
      *
      * use %module(directors="1") modulename at the start of the 
      * interface file to enable director generation.
      */
+    String* mod_docstring = NULL;
     {
-      Node *module = Getattr(n, "module");
-      if (module) {
-        Node *options = Getattr(module, "options");
+      Node *mod = Getattr(n, "module");
+      if (mod) {
+        Node *options = Getattr(mod, "options");
         if (options) {
           if (Getattr(options, "directors")) {
             allow_directors();
           }
           if (Getattr(options, "dirprot")) {
 	    allow_dirprot();
           }
+          mod_docstring = Getattr(options, "docstring");
+          package = Getattr(options, "package");
         }
       }
     }
 
@@ -257,8 +271,13 @@
           Printv(f_shadow,
                  "# This file is compatible with both classic and new-style classes.\n",
                  NIL);
       }
+
+      if (mod_docstring && Len(mod_docstring)) {
+        Printv(f_shadow, "\n\"\"\"\n", mod_docstring, "\n\"\"\"\n", NIL);
+        Delete(mod_docstring); mod_docstring = NULL;
+      }
       
       Printf(f_shadow,"\nimport %s\n\n", module);
 
       if (! modern) {
@@ -381,9 +400,28 @@
   virtual int importDirective(Node *n) {
     if (shadow) {
       String *modname = Getattr(n,"module");
       if (modname) {
-	Printf(f_shadow,"import %s\n", modname);
+        Printf(f_shadow,"import ");
+
+        // Find the module node for this imported module.  It should be the
+        // first child but search just in case.
+        Node* mod = firstChild(n);
+        while (mod && Strcmp(nodeType(mod), "module") != 0)
+          mod = nextSibling(mod);
+          
+        // Is the imported module in another package?  (IOW, does it use the
+        // %module(package="name") option and it's different than the package
+        // of this module.)
+        Node *options = Getattr(mod, "options");
+        if (options && Getattr(options, "package")) {
+          String* pkg = Getattr(options, "package");
+          if (!package || Strcmp(pkg, package) != 0)
+            Printf(f_shadow, "%s.", Getattr(options, "package"));
+        }
+
+        // finally, output the name of the imported module
+	Printf(f_shadow, "%s\n", modname);
       }
     }
     return Language::importDirective(n);
   }
@@ -416,17 +454,25 @@
    *    functions.
    * ------------------------------------------------------------ */
 
   void emitFunctionShadowHelper(Node *n, File *f_dest, String *name, int kw) {
-    if ( ! have_addtofunc(n) ) {
-      /* If there is no addtofunc directive then just assign from the extension module */
+    if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n) ) {
+      /* If there is no pythonappend or docstring directive then just assign from the extension module */
       Printv(f_dest, "\n", name, " = ", module, ".", name, "\n", NIL);
     } else {
       /* Otherwise make a wrapper function to insert the code into */
       Printv(f_dest, "\ndef ", name, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-      Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
-      Printv(f_dest, tab4, addtofunc(n), "\n", NIL);
-      Printv(f_dest, tab4, "return val\n", NIL);
+      if ( have_docstring(n) )
+        Printv(f_dest, tab4, docstring(n, AUTODOC_FUNC, tab4), "\n", NIL);
+      if ( have_pythonprepend(n) )
+        Printv(f_dest, tab4, pythonprepend(n), "\n", NIL);
+      if ( have_pythonappend(n) ) {
+        Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
+        Printv(f_dest, tab4, pythonappend(n), "\n", NIL);
+        Printv(f_dest, tab4, "return val\n", NIL);
+      } else {
+        Printv(f_dest, tab4, "return ", funcCallHelper(name, kw), "\n", NIL);
+      }        
     }
   }
 
 
@@ -440,24 +486,307 @@
   }
 
 
   /* ------------------------------------------------------------
-   * have_addtofunc()
-   *    Check if there is a %addtofunc directive and it has text
+   * have_docstring()
+   *    Check if there is a docstring directive and it has text,
+   *    or there is an autodoc flag set
    * ------------------------------------------------------------ */
 
-  bool have_addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  bool have_docstring(Node *n) {
+    String* str = Getattr(n, "feature:docstring");
+    return (str != NULL && Len(str) > 0) ||
+        (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+  }
+  
+  /* ------------------------------------------------------------
+   * docstring()
+   *    Get the docstring text, stripping off {} if neccessary,
+   *    and enclose in triple double quotes.  If autodoc is also
+   *    set then it will build a combined docstring.
+   * ------------------------------------------------------------ */
+
+  String *docstring(Node *n, autodoc_t ad_type, const String* indent) {
+    String* str = Getattr(n, "feature:docstring");
+    bool have_ds = (str != NULL && Len(str) > 0);
+    bool have_auto = (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+    char* triple_double = "\"\"\"";
+    String* autodoc = NULL;
+    String* doc = NULL;
+
+    if ( have_ds ) {
+      char* t = Char(str);
+      if (*t == '{') {
+        Delitem(str ,0);
+        Delitem(str,DOH_END);
+      }
+    }
+
+    if ( have_auto ) {
+      autodoc = make_autodoc(n, ad_type);
+      have_auto = (autodoc != NULL && Len(autodoc) > 0);
+    }
+    
+    // If there is more than one line then make docstrings like this:
+    //
+    //      """
+    //      This is line1
+    //      And here is line2 followed by the rest of them
+    //      """
+    //
+    // otherwise, put it all on a single line
+    //
+    if ( have_auto && have_ds ) {       // Both autodoc and docstring are present
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent), "\n",
+                  pythoncode(str, indent), 
+                  indent, triple_double, NIL);
+    }
+    else if ( !have_auto && have_ds ) { // only docstring
+      if (Strchr(str, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, str, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(str, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else if ( have_auto && !have_ds ) { // only autodoc
+      if (Strchr(autodoc, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, autodoc, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else
+      doc = NewString("");
+
+    // Save the generated strings in the parse tree in case they are used later
+    // by post processing tools
+    Setattr(n, "python:docstring", doc);
+    Setattr(n, "python:autodoc", autodoc);
+    return doc;
+  }
+
+
+  /* ------------------------------------------------------------
+   * make_autodoc()
+   *    Build a docstring for the node, using parameter and other
+   *    info in the parse tree.  If the value of the autodoc
+   *    attribute is "0" then do not include parameter types, if
+   *    it is "1" (the default) then do.  If it has some other
+   *    value then assume it is supplied by the extension writer
+   *    and use it directly.
+   * ------------------------------------------------------------ */
+
+  String* make_autodoc(Node *n, autodoc_t ad_type) {
+
+    if (ad_type == AUTODOC_CLASS)
+      return NULL;  // No function call to document in this case
+
+    // If the function is overloaded then this funciton is called
+    // for the last one.  Rewind to the first so the docstrings are
+    // in order.
+    while ( Getattr(n, "sym:previousSibling") )
+      n = Getattr(n, "sym:previousSibling");
+    
+    String* doc  = NewString("");
+    while (n) {
+      bool showTypes = false;
+      bool skipAuto = false;
+      
+      // check how should the parameters be rendered?
+      String* autodoc = Getattr(n, "feature:autodoc");
+      if (Strcmp(autodoc, "0") == 0)
+        showTypes = false;
+      else if (Strcmp(autodoc, "1") == 0)
+        showTypes = true;
+      else {
+        // if not "0" or "1" then autodoc is already the string that should be used
+        Printf(doc, "%s", autodoc);
+        skipAuto = true;
+      }
+
+      if (!skipAuto) {
+        String*   symname = Getattr(n, "sym:name");
+        SwigType* type    = Getattr(n, "type");
+      
+        if (type) {
+          if (Strcmp(type, "void") == 0)
+            type = NULL;
+          else {
+            SwigType* qt = SwigType_typedef_resolve_all(type);
+            if (SwigType_isenum(qt))
+              type = NewString("int");
+            else {
+              type = SwigType_base(type);
+              Node* lookup = Swig_symbol_clookup(type, 0);
+              if (lookup)
+                type = Getattr(lookup, "sym:name");
+            }
+          }     
+        }
+        
+        switch ( ad_type ) {
+        case AUTODOC_CTOR:
+          if ( Strcmp(class_name, symname) == 0) {
+            String* paramList = make_autodocParmList(n, showTypes);
+            if (Len(paramList))
+              Printf(doc, "__init__(self, %s) -> %s", paramList, class_name);
+            else
+              Printf(doc, "__init__(self) -> %s", class_name);
+          }              
+          else
+            Printf(doc, "%s(%s) -> %s", symname, make_autodocParmList(n, showTypes), class_name);
+          break;
+          
+        case AUTODOC_DTOR:
+          Printf(doc, "__del__(self)");
+          break;
+        
+        case AUTODOC_STATICFUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;
+                      
+        case AUTODOC_FUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+
+        case AUTODOC_METHOD:
+          String* paramList = make_autodocParmList(n, showTypes);
+          if (Len(paramList))
+            Printf(doc, "%s(self, %s)", symname, paramList);
+          else
+            Printf(doc, "%s(self)", symname);
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+        }
+      }
+      
+      // if it's overloaded then get the next decl and loop around again
+      n = Getattr(n, "sym:nextSibling");
+      if (n)
+        Printf(doc, "\n");
+    }
+          
+    return doc;
+  }
+
+
+  String* make_autodocParmList(Node* n, bool showTypes) {
+    String*   doc = NewString(""); 
+    ParmList* plist = Getattr(n,"parms");
+    Parm*     p;
+    Node*     lookup;
+    int       lines = 0;
+    const int maxwidth = 50;
+    
+
+    for (p = plist; p; p = nextSibling(p)) {
+      String*   name =  Getattr(p, "name");
+      String*   value = Getattr(p, "value");
+
+      if ( Len(doc) ) {
+        // add a comma to the previous one if any
+        Printf(doc, ", ");
+
+        // Do we need to wrap a long line?
+        if ((Len(doc) - lines*maxwidth) > maxwidth) {
+          Printf(doc, "\n%s", tab4);
+          lines += 1;
+        }
+      }
+        
+      // Do the param type too?
+      if (showTypes) {
+        SwigType* type =  SwigType_base(Getattr(p, "type"));
+        SwigType* qt = SwigType_typedef_resolve_all(type);
+        if (SwigType_isenum(qt))
+          type = NewString("int");
+        else {
+          lookup = Swig_symbol_clookup(type, 0);
+          if (lookup)
+            type = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "%s ", type);
+      }
+
+      if (name)
+        Printf(doc, "%s", name);
+      else
+        Printf(doc, "??");
+
+      if (value) {
+        if (Strcmp(value, "NULL") == 0)
+          value = NewString("None");
+        else if (Strcmp(value, "true") == 0 || Strcmp(value, "TRUE") == 0)
+          value = NewString("True");
+        else if (Strcmp(value, "false") == 0 || Strcmp(value, "FALSE") == 0)
+          value = NewString("False");
+        else {
+          lookup = Swig_symbol_clookup(value, 0);
+          if (lookup)
+            value = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "=%s", value);
+      }
+    }
+    
+    return doc;
+  }
+  
+  
+  /* ------------------------------------------------------------
+   * have_pythonprepend()
+   *    Check if there is a %pythonprepend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
+    return (str != NULL && Len(str) > 0);
+  }
+  
+  /* ------------------------------------------------------------
+   * pythonprepend()
+   *    Get the %pythonprepend code, stripping off {} if neccessary
+   * ------------------------------------------------------------ */
+
+  String *pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
+    char* t = Char(str);
+    if (*t == '{') {
+      Delitem(str ,0);
+      Delitem(str,DOH_END);
+    }
+    return str;
+  }
+    
+  /* ------------------------------------------------------------
+   * have_pythonappend()
+   *    Check if there is a %pythonappend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
     return (str != NULL && Len(str) > 0);
   }
   
   /* ------------------------------------------------------------
-   * addtofunc()
-   *    Get the %addtofunc code, stripping off {} if neccessary
+   * pythonappend()
+   *    Get the %pythonappend code, stripping off {} if neccessary
    * ------------------------------------------------------------ */
 
-  String *addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  String *pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
     char* t = Char(str);
     if (*t == '{') {
       Delitem(str ,0);
       Delitem(str,DOH_END);
@@ -1686,9 +2015,18 @@
       mod = Getattr(n,"module");
       if (mod) {
 	String *modname = Getattr(mod,"name");
 	if (Strcmp(modname,mainmodule) != 0) {
-	  importname = NewStringf("%s.%s", modname, Getattr(n,"sym:name"));
+          // check if the module has a package option
+          String* pkg = NULL;
+          Node *options = Getattr(mod, "options");
+          if (options && Getattr(options, "package")) 
+            pkg = Getattr(options, "package");
+
+          if (!package || Strcmp(pkg, package) != 0)
+            importname = NewStringf("%s.%s.%s", pkg, modname, Getattr(n,"sym:name"));
+          else
+            importname = NewStringf("%s.%s", modname, Getattr(n,"sym:name"));
 	} else {
 	  importname = NewString(Getattr(n,"sym:name"));
 	}
 	Setattr(n,"python:proxy",importname);
@@ -1760,9 +2098,11 @@
 	  Printf(f_shadow, modern ? "(object)" : "(_object)");
 	}
       }
       Printf(f_shadow,":\n");
-
+      if ( Getattr(n, "feature:docstring") ) // don't use have_docstring in this case because autodoc doesn't apply
+          Printv(f_shadow, tab4, docstring(n, AUTODOC_CLASS, tab4), "\n", NIL);
+      
       if (!modern) {
         Printv(f_shadow,tab4,"__swig_setmethods__ = {}\n",NIL);
         if (Len(base_class)) {
           Printf(f_shadow,"%sfor _s in [%s]: __swig_setmethods__.update(_s.__swig_setmethods__)\n",tab4,base_class);
@@ -1906,16 +2246,24 @@
 	  Delete(pyaction);
 	  Printv(f_shadow,pycode,"\n",NIL);
 	} else {
 
-          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "): ", NIL);
-          if ( have_addtofunc(n) ) {
-            Printv(f_shadow, "\n", NIL);
-            Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
-            Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-            Printv(f_shadow, tab8, "return val\n", NIL);
+          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "):", NIL);
+          if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n)) {
+            Printv(f_shadow, " return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
           } else {
-            Printv(f_shadow, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+            Printv(f_shadow, "\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_METHOD, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+            if ( have_pythonappend(n) ) {
+              Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+              Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+              Printv(f_shadow, tab8, "return val\n\n", NIL);
+            } else {
+              Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n\n", NIL);
+            }
           }
         }
 
       }
@@ -1930,14 +2278,22 @@
   virtual int staticmemberfunctionHandler(Node *n) {
     String *symname = Getattr(n,"sym:name");
     Language::staticmemberfunctionHandler(n);
     if (shadow) {
-      if ( !classic && have_addtofunc(n) ) {
+      if ( !classic && (have_pythonprepend(n) || have_pythonappend(n) || have_docstring(n)) ) {
         int kw = (check_kwargs(n) && !Getattr(n,"sym:overloaded")) ? 1 : 0;
         Printv(f_shadow, tab4, "def ", symname, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-        Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
-        Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-        Printv(f_shadow, tab8, "return val\n", NIL);
+        if ( have_docstring(n) )
+          Printv(f_shadow, tab8, docstring(n, AUTODOC_STATICFUNC, tab8), "\n", NIL);
+        if ( have_pythonprepend(n) )
+          Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+        if ( have_pythonappend(n) ) {
+          Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
+          Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+          Printv(f_shadow, tab8, "return val\n\n", NIL);
+        } else {
+          Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n\n", NIL);
+        }
         Printv(f_shadow, tab4, modern ? "" : "if _newclass:",  symname,
                " = staticmethod(", symname, ")\n", NIL);
 
         if (!modern) {
@@ -2022,8 +2378,12 @@
  	    }
 
             Printv(f_shadow, tab4, "def __init__(self, *args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_CTOR, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
             Printv(f_shadow, pass_self, NIL);
             if (!modern) {
               Printv(f_shadow, tab8, "_swig_setattr(self, ", rclassname, ", 'this', ", 
                      funcCallHelper(Swig_name_construct(symname), allow_kwargs), ")\n", NIL);
@@ -2036,10 +2396,10 @@
               Printv(f_shadow, tab8, "self.this = newobj.this\n", NIL);
               Printv(f_shadow, tab8, "self.thisown = 1\n", NIL);
               Printv(f_shadow, tab8, "del newobj.thisown\n", NIL);
             }
-            if ( have_addtofunc(n) )
-              Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow, tab8, pythonappend(n), "\n\n", NIL);
   	    Delete(pass_self);
   	  }
 	  have_constructor = 1;
 	} else {
@@ -2055,13 +2415,17 @@
 	  } else {
 
             Printv(f_shadow_stubs, "\ndef ", symname, "(*args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow_stubs, tab4, docstring(n, AUTODOC_CTOR, tab4), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow_stubs, tab4, pythonprepend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "val = ",
                    funcCallHelper(Swig_name_construct(symname), allow_kwargs), "\n", NIL);
 	    Printv(f_shadow_stubs, tab4, "val.thisown = 1\n", NIL);
-            if ( have_addtofunc(n) )
-              Printv(f_shadow_stubs, tab4, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow_stubs, tab4, pythonappend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "return val\n", NIL);
   	  }
 	}
       }
@@ -2088,13 +2452,18 @@
 	Delete(pyaction);
 	Printv(f_shadow,pycode,"\n", NIL);
       } else {
 	Printv(f_shadow, tab4, "def __del__(self, destroy=", module, ".", Swig_name_destroy(symname), "):\n", NIL);
-	if ( have_addtofunc(n) )
-	  Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+        if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_DTOR, tab8), "\n", NIL);
+	if ( have_pythonprepend(n) )
+	  Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
 	Printv(f_shadow, tab8, "try:\n", NIL);
-	Printv(f_shadow, tab4, tab8, "if self.thisown: destroy(self)\n", NIL);
+	Printv(f_shadow, tab8, tab4, "if self.thisown: destroy(self)\n", NIL);
 	Printv(f_shadow, tab8, "except: pass\n", NIL);
+	if ( have_pythonappend(n) )
+	  Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+        Printv(f_shadow, "\n", NIL);
       }
     }
     return SWIG_OK;
   }
