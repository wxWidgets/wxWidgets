Index: Source/Modules/python.cxx
===================================================================
RCS file: /cvsroot/swig/SWIG/Source/Modules/python.cxx,v
retrieving revision 1.40
diff -u -4 -r1.40 python.cxx
--- Source/Modules/python.cxx	24 Jan 2004 00:25:31 -0000	1.40
+++ Source/Modules/python.cxx	28 Apr 2004 22:20:03 -0000
@@ -8,9 +8,9 @@
  * Copyright (C) 1999-2000.  The University of Chicago
  * See the file LICENSE for information on usage and redistribution.
  * ----------------------------------------------------------------------------- */
 
-char cvsroot_python_cxx[] = "$Header$";
+char cvsroot_python_cxx[] = "$Header$";
 
 #include "swigmod.h"
 
 #include <ctype.h>
@@ -50,8 +50,18 @@
 static  int       have_constructor;
 static  int       have_repr;
 static  String   *real_classname;
 
+/* flags for the make_autodoc function */
+enum autodoc_t {
+  AUTODOC_CLASS,
+  AUTODOC_CTOR,
+  AUTODOC_DTOR,
+  AUTODOC_STATICFUNC,
+  AUTODOC_FUNC,
+  AUTODOC_METHOD
+};
+
 static const char *usage = (char *)"\
 Python Options (available with -python)\n\
      -ldflags        - Print runtime libraries to link with\n\
      -globals <name> - Set <name> used to access C global variable [default: 'cvar']\n\
@@ -417,17 +427,25 @@
    *    functions.
    * ------------------------------------------------------------ */
 
   void emitFunctionShadowHelper(Node *n, File *f_dest, String *name, int kw) {
-    if ( ! have_addtofunc(n) ) {
-      /* If there is no addtofunc directive then just assign from the extension module */
+    if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n) ) {
+      /* If there is no pythonappend or docstring directive then just assign from the extension module */
       Printv(f_dest, "\n", name, " = ", module, ".", name, "\n", NIL);
     } else {
       /* Otherwise make a wrapper function to insert the code into */
       Printv(f_dest, "\ndef ", name, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-      Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
-      Printv(f_dest, tab4, addtofunc(n), "\n", NIL);
-      Printv(f_dest, tab4, "return val\n", NIL);
+      if ( have_docstring(n) )
+        Printv(f_dest, tab4, docstring(n, AUTODOC_FUNC, tab4), "\n", NIL);
+      if ( have_pythonprepend(n) )
+        Printv(f_dest, tab4, pythonprepend(n), "\n", NIL);
+      if ( have_pythonappend(n) ) {
+        Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
+        Printv(f_dest, tab4, pythonappend(n), "\n", NIL);
+        Printv(f_dest, tab4, "return val\n", NIL);
+      } else {
+        Printv(f_dest, tab4, "return ", funcCallHelper(name, kw), "\n", NIL);
+      }        
     }
   }
 
 
@@ -441,24 +459,303 @@
   }
 
 
   /* ------------------------------------------------------------
-   * have_addtofunc()
-   *    Check if there is a %addtofunc directive and it has text
+   * have_docstring()
+   *    Check if there is a docstring directive and it has text,
+   *    or there is an autodoc flag set
+   * ------------------------------------------------------------ */
+
+  bool have_docstring(Node *n) {
+    String* str = Getattr(n, "feature:docstring");
+    return (str != NULL && Len(str) > 0) ||
+        (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+  }
+  
+  /* ------------------------------------------------------------
+   * docstring()
+   *    Get the docstring text, stripping off {} if neccessary,
+   *    and enclose in triple double quotes.  If autodoc is also
+   *    set then it will build a combined docstring.
+   * ------------------------------------------------------------ */
+
+  String *docstring(Node *n, autodoc_t ad_type, const String* indent) {
+    String* str = Getattr(n, "feature:docstring");
+    bool have_ds = (str != NULL && Len(str) > 0);
+    bool have_auto = (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+    char* triple_double = "\"\"\"";
+    String* autodoc = NULL;
+    String* doc = NULL;
+
+    if ( have_ds ) {
+      char* t = Char(str);
+      if (*t == '{') {
+        Delitem(str ,0);
+        Delitem(str,DOH_END);
+      }
+    }
+
+    if ( have_auto ) {
+      autodoc = make_autodoc(n, ad_type);
+      have_auto = (autodoc != NULL && Len(autodoc) > 0);
+    }
+    
+    // If there is more than one line then make docstrings like this:
+    //
+    //      """
+    //      This is line1
+    //      And here is line2 followed by the rest of them
+    //      """
+    //
+    // otherwise, put it all on a single line
+    //
+    if ( have_auto && have_ds ) {       // Both autodoc and docstring are present
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent), "\n",
+                  pythoncode(str, indent), 
+                  indent, triple_double, NIL);
+    }
+    else if ( !have_auto && have_ds ) { // only docstring
+      if (Strchr(str, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, str, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(str, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else if ( have_auto && !have_ds ) { // only autodoc
+      if (Strchr(autodoc, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, autodoc, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else
+      doc = NewString("");
+
+    // Save the generated strings in the parse tree in case they are used later
+    // by post processing tools
+    Setattr(n, "python:docstring", doc);
+    Setattr(n, "python:autodoc", autodoc);
+    return doc;
+  }
+
+
+  /* ------------------------------------------------------------
+   * make_autodoc()
+   *    Build a docstring for the node, using parameter and other
+   *    info in the parse tree.  If the value of the autodoc
+   *    attribute is "0" then do not include parameter types, if
+   *    it is "1" (the default) then do.  If it has some other
+   *    value then assume it is supplied by the extension writer
+   *    and use it directly.
    * ------------------------------------------------------------ */
 
-  bool have_addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  String* make_autodoc(Node *n, autodoc_t ad_type) {
+
+    if (ad_type == AUTODOC_CLASS)
+      return NULL;  // No function call to document in this case
+
+    // If the function is overloaded then this funciton is called
+    // for the last one.  Rewind to the first so the docstrings are
+    // in order.
+    while ( Getattr(n, "sym:previousSibling") )
+      n = Getattr(n, "sym:previousSibling");
+    
+    String* doc  = NewString("");
+    while (n) {
+      bool showTypes = false;
+      bool skipAuto = false;
+      
+      // check how should the parameters be rendered?
+      String* autodoc = Getattr(n, "feature:autodoc");
+      if (Strcmp(autodoc, "0") == 0)
+        showTypes = false;
+      else if (Strcmp(autodoc, "1") == 0)
+        showTypes = true;
+      else {
+        // if not "0" or "1" then autodoc is already the string that should be used
+        Printf(doc, "%s", autodoc);
+        skipAuto = true;
+      }
+
+      if (!skipAuto) {
+        String*   symname = Getattr(n, "sym:name");
+        SwigType* type    = Getattr(n, "type");
+      
+        if (type) {
+          if (Strcmp(type, "void") == 0)
+            type = NULL;
+          else {
+            SwigType* qt = SwigType_typedef_resolve_all(type);
+            if (SwigType_isenum(qt))
+              type = NewString("int");
+            else {
+              type = SwigType_base(type);
+              Node* lookup = Swig_symbol_clookup(type, 0);
+              if (lookup)
+                type = Getattr(lookup, "sym:name");
+            }
+          }     
+        }
+        
+        switch ( ad_type ) {
+        case AUTODOC_CTOR:
+          if ( Strcmp(class_name, symname) == 0) {
+            String* paramList = make_autodocParmList(n, showTypes);
+            if (Len(paramList))
+              Printf(doc, "__init__(self, %s) -> %s", paramList, class_name);
+            else
+              Printf(doc, "__init__(self) -> %s", class_name);
+          }              
+          else
+            Printf(doc, "%s(%s) -> %s", symname, make_autodocParmList(n, showTypes), class_name);
+          break;
+          
+        case AUTODOC_DTOR:
+          Printf(doc, "__del__(self)");
+          break;
+        
+        case AUTODOC_STATICFUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;
+                      
+        case AUTODOC_FUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+
+        case AUTODOC_METHOD:
+          String* paramList = make_autodocParmList(n, showTypes);
+          if (Len(paramList))
+            Printf(doc, "%s(self, %s)", symname, paramList);
+          else
+            Printf(doc, "%s(self)", symname);
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+        }
+      }
+      
+      // if it's overloaded then get the next decl and loop around again
+      n = Getattr(n, "sym:nextSibling");
+      if (n)
+        Printf(doc, "\n");
+    }
+          
+    return doc;
+  }
+
+
+  String* make_autodocParmList(Node* n, bool showTypes) {
+    String*   doc = NewString(""); 
+    ParmList* plist = Getattr(n,"parms");
+    Parm*     p;
+    Node*     lookup;
+    int       lines = 0;
+    const int maxwidth = 50;
+    
+
+    for (p = plist; p; p = nextSibling(p)) {
+      String*   name =  Getattr(p, "name");
+      String*   value = Getattr(p, "value");
+
+      if ( Len(doc) ) {
+        // add a comma to the previous one if any
+        Printf(doc, ", ");
+
+        // Do we need to wrap a long line?
+        if ((Len(doc) - lines*maxwidth) > maxwidth) {
+          Printf(doc, "\n%s", tab4);
+          lines += 1;
+        }
+      }
+        
+      // Do the param type too?
+      if (showTypes) {
+        SwigType* type =  SwigType_base(Getattr(p, "type"));
+        SwigType* qt = SwigType_typedef_resolve_all(type);
+        if (SwigType_isenum(qt))
+          type = NewString("int");
+        else {
+          lookup = Swig_symbol_clookup(type, 0);
+          if (lookup)
+            type = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "%s ", type);
+      }
+
+      if (name)
+        Printf(doc, "%s", name);
+      else
+        Printf(doc, "??");
+
+      if (value) {
+        if (Strcmp(value, "NULL") == 0)
+          value = NewString("None");
+        else {
+          lookup = Swig_symbol_clookup(value, 0);
+          if (lookup)
+            value = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "=%s", value);
+      }
+    }
+    
+    return doc;
+  }
+  
+  
+  /* ------------------------------------------------------------
+   * have_pythonprepend()
+   *    Check if there is a %pythonprepend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
+    return (str != NULL && Len(str) > 0);
+  }
+  
+  /* ------------------------------------------------------------
+   * pythonprepend()
+   *    Get the %pythonprepend code, stripping off {} if neccessary
+   * ------------------------------------------------------------ */
+
+  String *pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
+    char* t = Char(str);
+    if (*t == '{') {
+      Delitem(str ,0);
+      Delitem(str,DOH_END);
+    }
+    return str;
+  }
+    
+  /* ------------------------------------------------------------
+   * have_pythonappend()
+   *    Check if there is a %pythonappend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
     return (str != NULL && Len(str) > 0);
   }
   
   /* ------------------------------------------------------------
-   * addtofunc()
-   *    Get the %addtofunc code, stripping off {} if neccessary
+   * pythonappend()
+   *    Get the %pythonappend code, stripping off {} if neccessary
    * ------------------------------------------------------------ */
 
-  String *addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  String *pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
     char* t = Char(str);
     if (*t == '{') {
       Delitem(str ,0);
       Delitem(str,DOH_END);
@@ -1731,9 +2028,11 @@
 	  Printf(f_shadow, modern ? "(object)" : "(_object)");
 	}
       }
       Printf(f_shadow,":\n");
-
+      if ( Getattr(n, "feature:docstring") ) // don't use have_docstring in this case because autodoc doesn't apply
+          Printv(f_shadow, tab4, docstring(n, AUTODOC_CLASS, tab4), "\n", NIL);
+      
       if (!modern) {
         Printv(f_shadow,tab4,"__swig_setmethods__ = {}\n",NIL);
         if (Len(base_class)) {
           Printf(f_shadow,"%sfor _s in [%s]: __swig_setmethods__.update(_s.__swig_setmethods__)\n",tab4,base_class);
@@ -1866,16 +2165,24 @@
 	  Delete(pyaction);
 	  Printv(f_shadow,pycode,"\n",NIL);
 	} else {
 
-          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "): ", NIL);
-          if ( have_addtofunc(n) ) {
-            Printv(f_shadow, "\n", NIL);
-            Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
-            Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-            Printv(f_shadow, tab8, "return val\n", NIL);
+          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "):", NIL);
+          if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n)) {
+            Printv(f_shadow, " return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
           } else {
-            Printv(f_shadow, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+            Printv(f_shadow, "\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_METHOD, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+            if ( have_pythonappend(n) ) {
+              Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+              Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+              Printv(f_shadow, tab8, "return val\n\n", NIL);
+            } else {
+              Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n\n", NIL);
+            }
           }
         }
 
       }
@@ -1890,14 +2197,22 @@
   virtual int staticmemberfunctionHandler(Node *n) {
     String *symname = Getattr(n,"sym:name");
     Language::staticmemberfunctionHandler(n);
     if (shadow) {
-      if ( !classic && have_addtofunc(n) ) {
+      if ( !classic && (have_pythonprepend(n) || have_pythonappend(n) || have_docstring(n)) ) {
         int kw = (check_kwargs(n) && !Getattr(n,"sym:overloaded")) ? 1 : 0;
         Printv(f_shadow, tab4, "def ", symname, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-        Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
-        Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-        Printv(f_shadow, tab8, "return val\n", NIL);
+        if ( have_docstring(n) )
+          Printv(f_shadow, tab8, docstring(n, AUTODOC_STATICFUNC, tab8), "\n", NIL);
+        if ( have_pythonprepend(n) )
+          Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+        if ( have_pythonappend(n) ) {
+          Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
+          Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+          Printv(f_shadow, tab8, "return val\n\n", NIL);
+        } else {
+          Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n\n", NIL);
+        }
         Printv(f_shadow, tab4, modern ? "" : "if _newclass:",  symname,
                " = staticmethod(", symname, ")\n", NIL);
 
         if (!modern) {
@@ -1982,8 +2297,12 @@
  	    }
 
             Printv(f_shadow, tab4, "def __init__(self, *args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_CTOR, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
             Printv(f_shadow, pass_self, NIL);
             if (!modern) {
               Printv(f_shadow, tab8, "_swig_setattr(self, ", rclassname, ", 'this', ", 
                      funcCallHelper(Swig_name_construct(symname), allow_kwargs), ")\n", NIL);
@@ -1996,10 +2315,10 @@
               Printv(f_shadow, tab8, "self.this = newobj.this\n", NIL);
               Printv(f_shadow, tab8, "self.thisown = 1\n", NIL);
               Printv(f_shadow, tab8, "del newobj.thisown\n", NIL);
             }
-            if ( have_addtofunc(n) )
-              Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow, tab8, pythonappend(n), "\n\n", NIL);
   	    Delete(pass_self);
   	  }
 	  have_constructor = 1;
 	} else {
@@ -2015,13 +2334,17 @@
 	  } else {
 
             Printv(f_shadow_stubs, "\ndef ", symname, "(*args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow_stubs, tab4, docstring(n, AUTODOC_CTOR, tab4), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow_stubs, tab4, pythonprepend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "val = ",
                    funcCallHelper(Swig_name_construct(symname), allow_kwargs), "\n", NIL);
 	    Printv(f_shadow_stubs, tab4, "val.thisown = 1\n", NIL);
-            if ( have_addtofunc(n) )
-              Printv(f_shadow_stubs, tab4, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow_stubs, tab4, pythonappend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "return val\n", NIL);
   	  }
 	}
       }
@@ -2048,13 +2371,18 @@
 	Delete(pyaction);
 	Printv(f_shadow,pycode,"\n", NIL);
       } else {
 	Printv(f_shadow, tab4, "def __del__(self, destroy=", module, ".", Swig_name_destroy(symname), "):\n", NIL);
-	if ( have_addtofunc(n) )
-	  Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+        if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_DTOR, tab8), "\n", NIL);
+	if ( have_pythonprepend(n) )
+	  Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
 	Printv(f_shadow, tab8, "try:\n", NIL);
-	Printv(f_shadow, tab4, tab8, "if self.thisown: destroy(self)\n", NIL);
+	Printv(f_shadow, tab8, tab4, "if self.thisown: destroy(self)\n", NIL);
 	Printv(f_shadow, tab8, "except: pass\n", NIL);
+	if ( have_pythonappend(n) )
+	  Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+        Printv(f_shadow, "\n", NIL);
       }
     }
     return SWIG_OK;
   }
