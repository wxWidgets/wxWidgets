////////////////////////////////////////////////////////////////////////////
// Name:        stc.cpp
// Purpose:     A wxWidgets implementation of Scintilla.  This class is the
//              one meant to be used directly by wx applications.  It does not
//              derive directly from the Scintilla classes, but instead
//              delegates most things to the real Scintilla class.
//              This allows the use of Scintilla without polluting the
//              namespace with all the classes and identifiers from Scintilla.
//
// Author:      Robin Dunn
//
// Created:     13-Jan-2000
// Copyright:   (c) 2000 by Total Control Software
// Licence:     wxWindows licence
/////////////////////////////////////////////////////////////////////////////

/*
    IMPORTANT: src/stc/stc.cpp is generated by src/stc/gen_iface.py from
               src/stc/stc.cpp.in, don't edit stc.cpp file as your changes will be
               lost after the next regeneration, edit stc.cpp.in and rerun the
               gen_iface.py script instead!

               Parts of this file generated by the script are found in between
               the special "{{{" and "}}}" markers, the rest of it is copied
               verbatim from src.h.in.
 */

// For compilers that support precompilation, includes "wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
    #pragma hdrstop
#endif

#if wxUSE_STC

#include "wx/stc/stc.h"
#include "wx/stc/private.h"

#ifndef WX_PRECOMP
    #include "wx/wx.h"
#endif // WX_PRECOMP

#include <ctype.h>

#include "wx/tokenzr.h"
#include "wx/mstream.h"
#include "wx/image.h"
#include "wx/vlbox.h"
#include "wx/stack.h"
#if wxUSE_FFILE
    #include "wx/ffile.h"
#elif wxUSE_FILE
    #include "wx/file.h"
#endif

#include "wx/dcbuffer.h"

#include "ScintillaWX.h"

//----------------------------------------------------------------------

const char wxSTCNameStr[] = "stcwindow";

#ifdef MAKELONG
#undef MAKELONG
#endif

#define MAKELONG(a, b) ((a) | ((b) << 16))


static long wxColourAsLong(const wxColour& co) {
    return (((long)co.Blue()  << 16) |
            ((long)co.Green() <<  8) |
            ((long)co.Red()));
}

static wxColour wxColourFromLong(long c) {
    wxColour clr;
    clr.Set((unsigned char)(c & 0xff),
            (unsigned char)((c >> 8) & 0xff),
            (unsigned char)((c >> 16) & 0xff));
    return clr;
}


static wxColour wxColourFromSpec(const wxString& spec) {
    // spec should be a colour name or "#RRGGBB"
    if (spec.GetChar(0) == wxT('#')) {

        long red, green, blue;
        red = green = blue = 0;
        spec.Mid(1,2).ToLong(&red,   16);
        spec.Mid(3,2).ToLong(&green, 16);
        spec.Mid(5,2).ToLong(&blue,  16);
        return wxColour((unsigned char)red,
                        (unsigned char)green,
                        (unsigned char)blue);
    }
    else
        return wxColour(spec);
}

//----------------------------------------------------------------------

wxDEFINE_EVENT( wxEVT_STC_CHANGE, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_STYLENEEDED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_CHARADDED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_SAVEPOINTREACHED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_SAVEPOINTLEFT, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_ROMODIFYATTEMPT, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_KEY, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_DOUBLECLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_UPDATEUI, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_MODIFIED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_MACRORECORD, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_MARGINCLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_NEEDSHOWN, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_PAINTED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_USERLISTSELECTION, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_URIDROPPED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_DWELLSTART, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_DWELLEND, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_START_DRAG, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_DRAG_OVER, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_DO_DROP, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_ZOOM, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_HOTSPOT_CLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_HOTSPOT_DCLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_CALLTIP_CLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_SELECTION, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_INDICATOR_CLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_INDICATOR_RELEASE, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_CANCELLED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_CHAR_DELETED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_HOTSPOT_RELEASE_CLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_CLIPBOARD_COPY, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_CLIPBOARD_PASTE, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_COMPLETED, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_MARGIN_RIGHT_CLICK, wxStyledTextEvent );
wxDEFINE_EVENT( wxEVT_STC_AUTOCOMP_SELECTION_CHANGE, wxStyledTextEvent );


wxBEGIN_EVENT_TABLE(wxStyledTextCtrl, wxControl)
    EVT_PAINT                   (wxStyledTextCtrl::OnPaint)
    EVT_SCROLLWIN               (wxStyledTextCtrl::OnScrollWin)
    EVT_SCROLL                  (wxStyledTextCtrl::OnScroll)
    EVT_SIZE                    (wxStyledTextCtrl::OnSize)
    EVT_LEFT_DOWN               (wxStyledTextCtrl::OnMouseLeftDown)
    EVT_RIGHT_DOWN              (wxStyledTextCtrl::OnMouseRightDown)
    // Let Scintilla see the double click as a second click
    EVT_LEFT_DCLICK             (wxStyledTextCtrl::OnMouseLeftDown)
    EVT_MOTION                  (wxStyledTextCtrl::OnMouseMove)
    EVT_LEFT_UP                 (wxStyledTextCtrl::OnMouseLeftUp)
    EVT_CONTEXT_MENU            (wxStyledTextCtrl::OnContextMenu)
    EVT_MOUSEWHEEL              (wxStyledTextCtrl::OnMouseWheel)
    EVT_MIDDLE_UP               (wxStyledTextCtrl::OnMouseMiddleUp)
    EVT_CHAR                    (wxStyledTextCtrl::OnChar)
    EVT_KEY_DOWN                (wxStyledTextCtrl::OnKeyDown)
    EVT_KILL_FOCUS              (wxStyledTextCtrl::OnLoseFocus)
    EVT_SET_FOCUS               (wxStyledTextCtrl::OnGainFocus)
    EVT_DPI_CHANGED             (wxStyledTextCtrl::OnDPIChanged)
    EVT_SYS_COLOUR_CHANGED      (wxStyledTextCtrl::OnSysColourChanged)
    EVT_ERASE_BACKGROUND        (wxStyledTextCtrl::OnEraseBackground)
    EVT_MENU_RANGE              (10, 16, wxStyledTextCtrl::OnMenu)
    EVT_LISTBOX_DCLICK          (wxID_ANY, wxStyledTextCtrl::OnListBox)
    EVT_MOUSE_CAPTURE_LOST      (wxStyledTextCtrl::OnMouseCaptureLost)
wxEND_EVENT_TABLE()


wxIMPLEMENT_CLASS(wxStyledTextCtrl, wxControl);
wxIMPLEMENT_DYNAMIC_CLASS(wxStyledTextEvent, wxCommandEvent);

#ifdef LINK_LEXERS
// forces the linking of the lexer modules
int Scintilla_LinkLexers();
#endif

//----------------------------------------------------------------------
// Constructor and Destructor

wxStyledTextCtrl::wxStyledTextCtrl(wxWindow *parent,
                                   wxWindowID id,
                                   const wxPoint& pos,
                                   const wxSize& size,
                                   long style,
                                   const wxString& name)
{
    m_swx = NULL;
    Create(parent, id, pos, size, style, name);
}


bool wxStyledTextCtrl::Create(wxWindow *parent,
                              wxWindowID id,
                              const wxPoint& pos,
                              const wxSize& size,
                              long style,
                              const wxString& name)
{
    style |= wxVSCROLL | wxHSCROLL;
    if (!wxControl::Create(parent, id, pos, size,
                           style | wxWANTS_CHARS | wxCLIP_CHILDREN,
                           wxDefaultValidator, name))
        return false;

#ifdef LINK_LEXERS
    Scintilla_LinkLexers();
#endif
    m_swx = new ScintillaWX(this);
    m_stopWatch.Start();
    m_lastKeyDownConsumed = false;
    m_vScrollBar = NULL;
    m_hScrollBar = NULL;
#if wxUSE_UNICODE
    // Put Scintilla into unicode (UTF-8) mode
    SetCodePage(wxSTC_CP_UTF8);
#endif

    SetInitialSize(size);

    // Reduces flicker on GTK+/X11
    SetBackgroundStyle(wxBG_STYLE_PAINT);

    // Make sure it can take the focus
    SetCanFocus(true);

    // STC doesn't support RTL languages at all
    SetLayoutDirection(wxLayout_LeftToRight);

    // Rely on native double buffering by default, except under Mac where it
    // doesn't work for some reason, see #18085.
#if wxALWAYS_NATIVE_DOUBLE_BUFFER && !defined(__WXMAC__)
    SetBufferedDraw(false);
#else
    SetBufferedDraw(true);
#endif

#if wxUSE_GRAPHICS_DIRECT2D
    SetFontQuality(wxSTC_EFF_QUALITY_DEFAULT);
#endif

    return true;
}


wxStyledTextCtrl::~wxStyledTextCtrl() {
    delete m_swx;
}


//----------------------------------------------------------------------

wxIntPtr wxStyledTextCtrl::SendMsg(int msg, wxUIntPtr wp, wxIntPtr lp) const
{
    return m_swx->WndProc(msg, wp, lp);
}

//----------------------------------------------------------------------

// Set the vertical scrollbar to use instead of the one that's built-in.
void wxStyledTextCtrl::SetVScrollBar(wxScrollBar* bar)  {
    m_vScrollBar = bar;
    if (bar != NULL) {
        // ensure that the built-in scrollbar is not visible
        SetScrollbar(wxVERTICAL, 0, 0, 0);
    }
}


// Set the horizontal scrollbar to use instead of the one that's built-in.
void wxStyledTextCtrl::SetHScrollBar(wxScrollBar* bar)  {
    m_hScrollBar = bar;
    if (bar != NULL) {
        // ensure that the built-in scrollbar is not visible
        SetScrollbar(wxHORIZONTAL, 0, 0, 0);
    }
}

//----------------------------------------------------------------------
// Generated methods implementation section {{{

%(METHOD_IMPS)s

//}}}
//----------------------------------------------------------------------


// Returns the line number of the line with the caret.
int wxStyledTextCtrl::GetCurrentLine() {
    int line = LineFromPosition(GetCurrentPos());
    return line;
}


// Extract style settings from a spec-string which is composed of one or
// more of the following comma separated elements:
//
//      bold                    turns on bold
//      italic                  turns on italics
//      fore:[name or #RRGGBB]  sets the foreground colour
//      back:[name or #RRGGBB]  sets the background colour
//      face:[facename]         sets the font face name to use
//      size:[num]              sets the font size in points
//      eol                     turns on eol filling
//      underline               turns on underlining
//
void wxStyledTextCtrl::StyleSetSpec(int styleNum, const wxString& spec) {

    wxStringTokenizer tkz(spec, wxT(","));
    while (tkz.HasMoreTokens()) {
        wxString token = tkz.GetNextToken();

        wxString option = token.BeforeFirst(':');
        wxString val = token.AfterFirst(':');

        if (option == wxT("bold"))
            StyleSetBold(styleNum, true);

        else if (option == wxT("italic"))
            StyleSetItalic(styleNum, true);

        else if (option == wxT("underline"))
            StyleSetUnderline(styleNum, true);

        else if (option == wxT("eol"))
            StyleSetEOLFilled(styleNum, true);

        else if (option == wxT("size")) {
            long points;
            if (val.ToLong(&points))
                StyleSetSize(styleNum, points);
        }

        else if (option == wxT("face"))
            StyleSetFaceName(styleNum, val);

        else if (option == wxT("fore"))
            StyleSetForeground(styleNum, wxColourFromSpec(val));

        else if (option == wxT("back"))
            StyleSetBackground(styleNum, wxColourFromSpec(val));
    }
}


// Get the font of a style
wxFont wxStyledTextCtrl::StyleGetFont(int style) {
    wxFont font;
    font.SetPointSize(StyleGetSize(style));
    font.SetFaceName(StyleGetFaceName(style));
    if( StyleGetBold(style) )
        font.SetWeight(wxFONTWEIGHT_BOLD);
    else
        font.SetWeight(wxFONTWEIGHT_NORMAL);

    if( StyleGetItalic(style) )
        font.SetStyle(wxFONTSTYLE_ITALIC);
    else
        font.SetStyle(wxFONTSTYLE_NORMAL);

    return font;
}


// Set style size, face, bold, italic, and underline attributes from
// a wxFont's attributes.
void wxStyledTextCtrl::StyleSetFont(int styleNum, const wxFont& font) {
#ifdef __WXGTK__
    // Ensure that the native font is initialized
    int x, y;
    GetTextExtent(wxT("X"), &x, &y, NULL, NULL, &font);
#endif
    int            size     = font.GetPointSize();
    wxString       faceName = font.GetFaceName();
    bool           bold     = font.GetWeight() == wxFONTWEIGHT_BOLD;
    bool           italic   = font.GetStyle() != wxFONTSTYLE_NORMAL;
    bool           under    = font.GetUnderlined();
    wxFontEncoding encoding = font.GetEncoding();

    StyleSetFontAttr(styleNum, size, faceName, bold, italic, under, encoding);
}

// Set all font style attributes at once.
void wxStyledTextCtrl::StyleSetFontAttr(int styleNum, int size,
                                        const wxString& faceName,
                                        bool bold, bool italic,
                                        bool underline,
                                        wxFontEncoding encoding) {
    StyleSetSize(styleNum, size);
    StyleSetFaceName(styleNum, faceName);
    StyleSetBold(styleNum, bold);
    StyleSetItalic(styleNum, italic);
    StyleSetUnderline(styleNum, underline);
    StyleSetFontEncoding(styleNum, encoding);
}


// Set the font encoding to be used by a style.
void wxStyledTextCtrl::StyleSetFontEncoding(int style, wxFontEncoding encoding)
{
    SendMsg(SCI_STYLESETCHARACTERSET, style, encoding+1);
}


// Perform one of the operations defined by the wxSTC_CMD_* constants.
void wxStyledTextCtrl::CmdKeyExecute(int cmd) {
    SendMsg(cmd);
}


// Set the left and right margin in the edit area, measured in pixels.
void wxStyledTextCtrl::SetMargins(int left, int right) {
    SetMarginLeft(left);
    SetMarginRight(right);
}


// Scroll enough to make the given line visible
void wxStyledTextCtrl::ScrollToLine(int line) {
    m_swx->DoScrollToLine(line);
}


// Scroll enough to make the given column visible
void wxStyledTextCtrl::ScrollToColumn(int column) {
    m_swx->DoScrollToColumn(column);
}


void wxStyledTextCtrl::DoSetValue(const wxString& value, int flags)
{
    if ( flags & SetValue_SelectionOnly )
        ReplaceSelection(value);
    else
        SetText(value);

    // We don't send wxEVT_TEXT anyhow, so ignore the
    // SetValue_SendEvent bit of the flags
}

bool
wxStyledTextCtrl::DoSaveFile(const wxString& filename, int WXUNUSED(fileType))
{
#if wxUSE_FFILE || wxUSE_FILE

#if wxUSE_FFILE
    // Take care to use "b" to ensure that possibly non-native EOLs in the file
    // contents are not mangled when saving it.
    wxFFile file(filename, wxS("wb"));
#elif wxUSE_FILE
    wxFile file(filename, wxFile::write);
#endif

    if ( file.IsOpened() && file.Write(GetValue(), *wxConvCurrent) )
    {
        SetSavePoint();

        return true;
    }

#endif // !wxUSE_FFILE && !wxUSE_FILE

    return false;
}

bool
wxStyledTextCtrl::DoLoadFile(const wxString& filename, int WXUNUSED(fileType))
{
#if wxUSE_FFILE || wxUSE_FILE

#if wxUSE_FFILE
    // As above, we want to read the real EOLs from the file, e.g. without
    // translating them to just LFs under Windows, so that the original CR LF
    // are preserved when it's written back.
    wxFFile file(filename, wxS("rb"));
#else
    wxFile file(filename);
#endif

    if ( file.IsOpened() )
    {
        wxString text;
        if ( file.ReadAll(&text, wxConvAuto()) )
        {
            // Detect the EOL: we use just the first line because there is not
            // much we can do if the file uses inconsistent EOLs anyhow, we'd
            // need to ask the user about the one we should really use and we
            // don't currently provide a way to do it.
            //
            // We also only check for Unix and DOS EOLs but not classic Mac
            // CR-only one as it's obsolete by now.
            const wxString::size_type posLF = text.find('\n');
            if ( posLF != wxString::npos )
            {
                // Set EOL mode to ensure that the new lines inserted into the
                // text use the same EOLs as the existing ones.
                if ( posLF > 0 && text[posLF - 1] == '\r' )
                    SetEOLMode(wxSTC_EOL_CRLF);
                else
                    SetEOLMode(wxSTC_EOL_LF);
            }
            //else: Use the default EOL for the current platform.

            SetValue(text);
            EmptyUndoBuffer();
            SetSavePoint();

            return true;
        }
    }
#endif // !wxUSE_FFILE && !wxUSE_FILE

   return false;
}

// If we don't derive from wxTextAreaBase, we need to implement these methods
// ourselves, otherwise we already inherit them.
#if !wxUSE_TEXTCTRL

bool wxStyledTextCtrl::SaveFile(const wxString& filename)
{
    if ( filename.empty() )
        return false;

    return DoSaveFile(filename, wxTEXT_TYPE_ANY);
}

bool wxStyledTextCtrl::LoadFile(const wxString& filename)
{
    if ( filename.empty() )
        return false;

    return DoLoadFile(filename, wxTEXT_TYPE_ANY);
}

#endif // !wxUSE_TEXTCTRL

#if wxUSE_DRAG_AND_DROP
wxDragResult wxStyledTextCtrl::DoDragEnter(wxCoord x, wxCoord y, wxDragResult def) {
    return m_swx->DoDragEnter(x, y, def);
}

wxDragResult wxStyledTextCtrl::DoDragOver(wxCoord x, wxCoord y, wxDragResult def) {
    return m_swx->DoDragOver(x, y, def);
}

void wxStyledTextCtrl::DoDragLeave() {
    m_swx->DoDragLeave();
}

bool wxStyledTextCtrl::DoDropText(long x, long y, const wxString& data) {
    return m_swx->DoDropText(x, y, data);
}
#endif


void wxStyledTextCtrl::SetUseAntiAliasing(bool useAA) {
    m_swx->SetUseAntiAliasing(useAA);
}

bool wxStyledTextCtrl::GetUseAntiAliasing() {
    return m_swx->GetUseAntiAliasing();
}

void wxStyledTextCtrl::AnnotationClearLine(int line) {
    SendMsg(SCI_ANNOTATIONSETTEXT, line, (sptr_t)NULL);
}

void wxStyledTextCtrl::MarkerDefineBitmap(int markerNumber,
                                          const wxBitmap& bmp) {
    m_swx->DoMarkerDefineBitmap(markerNumber, bmp);
}

void wxStyledTextCtrl::RegisterImage(int type, const wxBitmap& bmp)
{
    m_swx->DoRegisterImage(type, bmp);
}




void wxStyledTextCtrl::AddTextRaw(const char* text, int length)
{
    if (length == -1)
        length = strlen(text);
    SendMsg(SCI_ADDTEXT, length, (sptr_t)text);
}

void wxStyledTextCtrl::InsertTextRaw(int pos, const char* text)
{
    SendMsg(SCI_INSERTTEXT, pos, (sptr_t)text);
}

wxCharBuffer wxStyledTextCtrl::GetCurLineRaw(int* linePos)
{
    int len = LineLength(GetCurrentLine());
    if (!len) {
        if (linePos)  *linePos = 0;
        wxCharBuffer empty;
        return empty;
    }

    wxCharBuffer buf(len);
    int pos = SendMsg(SCI_GETCURLINE, len, (sptr_t)buf.data());
    if (linePos)  *linePos = pos;
    return buf;
}

wxCharBuffer wxStyledTextCtrl::GetLineRaw(int line)
{
    int len = LineLength(line);
    if (!len) {
        wxCharBuffer empty;
        return empty;
    }

    wxCharBuffer buf(len);
    SendMsg(SCI_GETLINE, line, (sptr_t)buf.data());
    return buf;
}

wxCharBuffer wxStyledTextCtrl::GetSelectedTextRaw()
{
    // Calculate the length needed first.
    const int len = SendMsg(SCI_GETSELTEXT, 0, (sptr_t)0);

    // And then really get the data.
    wxCharBuffer buf(len);
    SendMsg(SCI_GETSELTEXT, 0, (sptr_t)buf.data());
    return buf;
}

wxCharBuffer wxStyledTextCtrl::GetTargetTextRaw()
{
    // Calculate the length needed first.
    const int len = SendMsg(SCI_GETTARGETEND, 0, 0) - SendMsg(SCI_GETTARGETSTART, 0, 0);

    // And then really get the data.
    wxCharBuffer buf(len);
    SendMsg(SCI_GETTARGETTEXT, 0, (sptr_t)buf.data());
    return buf;
}

wxCharBuffer wxStyledTextCtrl::GetTextRangeRaw(int startPos, int endPos)
{
    if (endPos < startPos) {
        wxSwap(startPos, endPos);
    }
    int len  = endPos - startPos;
    if (!len) {
        wxCharBuffer empty;
        return empty;
    }

    wxCharBuffer buf(len);
    Sci_TextRange tr;
    tr.lpstrText = buf.data();
    tr.chrg.cpMin = startPos;
    tr.chrg.cpMax = endPos;
    tr.lpstrText[0] = '\0'; // initialize with 0 in case the range is invalid
    SendMsg(SCI_GETTEXTRANGE, 0, (sptr_t)&tr);
    return buf;
}

void wxStyledTextCtrl::SetTextRaw(const char* text)
{
    SendMsg(SCI_SETTEXT, 0, (sptr_t)text);
}

wxCharBuffer wxStyledTextCtrl::GetTextRaw()
{
    int len = GetTextLength();
    wxCharBuffer buf(len); // adds 1 for NUL automatically
    SendMsg(SCI_GETTEXT, len + 1, (sptr_t)buf.data());
    return buf;
}

void wxStyledTextCtrl::AppendTextRaw(const char* text, int length)
{
    if (length == -1)
        length = strlen(text);
    SendMsg(SCI_APPENDTEXT, length, (sptr_t)text);
}

void wxStyledTextCtrl::ReplaceSelectionRaw(const char* text)
{
    SendMsg(SCI_REPLACESEL, 0, reinterpret_cast<sptr_t>(text));
}

int wxStyledTextCtrl::ReplaceTargetRaw(const char* text, int length)
{
    if ( length == -1 )
        length = strlen(text);

    return SendMsg(SCI_REPLACETARGET, length, reinterpret_cast<sptr_t>(text));
}

int wxStyledTextCtrl::ReplaceTargetRERaw(const char* text, int length)
{
    if ( length == -1 )
        length = strlen(text);

    return SendMsg(SCI_REPLACETARGETRE, length, reinterpret_cast<sptr_t>(text));
}

#if WXWIN_COMPATIBILITY_3_0
// Deprecated since Scintilla 3.7.2
void wxStyledTextCtrl::UsePopUp(bool allowPopUp)
{
    SendMsg(SCI_USEPOPUP, allowPopUp ? SC_POPUP_ALL : SC_POPUP_NEVER, 0);
}

void wxStyledTextCtrl::StartStyling(int start, int unused)
{
        wxASSERT_MSG(unused==0,
                     "The second argument passed to StartStyling should be 0");

        SendMsg(SCI_STARTSTYLING, start, unused);
}
#endif // WXWIN_COMPATIBILITY_3_0

//----------------------------------------------------------------------
// Event handlers

void wxStyledTextCtrl::OnPaint(wxPaintEvent& WXUNUSED(evt)) {
    wxPaintDC dc(this);
    m_swx->DoPaint(&dc, GetUpdateRegion().GetBox());
}

void wxStyledTextCtrl::OnScrollWin(wxScrollWinEvent& evt) {
    if (evt.GetOrientation() == wxHORIZONTAL)
        m_swx->DoHScroll(evt.GetEventType(), evt.GetPosition());
    else
        m_swx->DoVScroll(evt.GetEventType(), evt.GetPosition());
}

void wxStyledTextCtrl::OnScroll(wxScrollEvent& evt) {
    wxScrollBar* sb = wxDynamicCast(evt.GetEventObject(), wxScrollBar);
    if (sb) {
        if (sb->IsVertical())
            m_swx->DoVScroll(evt.GetEventType(), evt.GetPosition());
        else
            m_swx->DoHScroll(evt.GetEventType(), evt.GetPosition());
    }
}

void wxStyledTextCtrl::OnSize(wxSizeEvent& WXUNUSED(evt)) {
    if (m_swx) {
        wxSize sz = GetClientSize();
        m_swx->DoSize(sz.x, sz.y);
    }
}

void wxStyledTextCtrl::OnMouseLeftDown(wxMouseEvent& evt) {
    SetFocus();
    wxPoint pt = evt.GetPosition();
    m_swx->DoLeftButtonDown(Point(pt.x, pt.y), m_stopWatch.Time(),
                      evt.ShiftDown(), evt.ControlDown(), evt.AltDown());
}

void wxStyledTextCtrl::OnMouseRightDown(wxMouseEvent& evt) {
    SetFocus();
    wxPoint pt = evt.GetPosition();
    m_swx->DoRightButtonDown(Point(pt.x, pt.y), m_stopWatch.Time(),
                      evt.ShiftDown(), evt.ControlDown(), evt.AltDown());
    // We need to call evt.Skip() to allow generating EVT_CONTEXT_MENU
    evt.Skip();
}

void wxStyledTextCtrl::OnMouseMove(wxMouseEvent& evt) {
    wxPoint pt = evt.GetPosition();
    m_swx->DoLeftButtonMove(Point(pt.x, pt.y));
}

void wxStyledTextCtrl::OnMouseLeftUp(wxMouseEvent& evt) {
    wxPoint pt = evt.GetPosition();
    m_swx->DoLeftButtonUp(Point(pt.x, pt.y), m_stopWatch.Time(),
                      evt.ControlDown());
}

void wxStyledTextCtrl::OnMouseMiddleUp(wxMouseEvent& evt) {
    wxPoint pt = evt.GetPosition();
    m_swx->DoMiddleButtonUp(Point(pt.x, pt.y));
}

void wxStyledTextCtrl::OnContextMenu(wxContextMenuEvent& evt) {
    wxPoint pt = evt.GetPosition();
    ScreenToClient(&pt.x, &pt.y);
    /*
      Show context menu at event point if it's within the window,
      or at caret location if not
    */
    wxHitTest ht = this->HitTest(pt);
    if (ht != wxHT_WINDOW_INSIDE) {
        pt = this->PointFromPosition(this->GetCurrentPos());
    }
    if ( !m_swx->DoContextMenu(Point(pt.x, pt.y)) )
        evt.Skip();
}


void wxStyledTextCtrl::OnMouseWheel(wxMouseEvent& evt)
{
    // The default action of this method is to call m_swx->DoMouseWheel.
    // However, it might be necessary to do something else depending on whether
    //     1) the mouse wheel captures for the STC,
    //     2) the event's position is in the STC's rect, and
    //     3) and an autocompletion list is currently being shown.
    // This table summarizes when each action is needed.

    // InRect | MouseWheelCaptures | Autocomp Active |      action
    // -------+--------------------+-----------------+-------------------
    //  true  |       true         |      true       | scroll ac list
    //  true  |       true         |      false      | default
    //  true  |       false        |      true       | scroll ac list
    //  true  |       false        |      false      | default
    //  false |       true         |      true       | scroll ac list
    //  false |       true         |      false      | default
    //  false |       false        |      true       | forward to parent
    //  false |       false        |      false      | forward to parent

    // if the mouse wheel is not captured, test if the mouse
    // pointer is over the editor window and if not, don't
    // handle the message but pass it on.
    if ( !GetMouseWheelCaptures() && !GetRect().Contains(evt.GetPosition()) )
    {
        wxWindow* parent = GetParent();
        if ( parent != NULL )
        {
            wxMouseEvent newevt(evt);
            newevt.SetPosition(
                parent->ScreenToClient(ClientToScreen(evt.GetPosition())));
            parent->ProcessWindowEvent(newevt);
        }
    }
    else if ( AutoCompActive() )
    {
        // When the autocompletion popup is active, Scintilla uses the mouse
        // wheel to scroll the autocomp list instead of the editor.

        // First try to find the list. It will be a wxVListBox named
        // "AutoCompListBox".
        wxWindow* curWin  = this, *acListBox = NULL;
        wxStack<wxWindow*> windows;
        windows.push(curWin);

        while ( !windows.empty() )
        {
            curWin = windows.top();
            windows.pop();

            if ( curWin->IsKindOf(wxCLASSINFO(wxVListBox)) &&
                    curWin->GetName() == "AutoCompListBox")
            {
                acListBox = curWin;
                break;
            }

            wxWindowList& children = curWin->GetChildren();
            wxWindowList::iterator it;

            for ( it = children.begin(); it!=children.end(); ++it )
            {
                windows.push(*it);
            }
        }

        // Next if the list was found, send it a copy of this event.
        if ( acListBox )
        {
            wxMouseEvent newevt(evt);
            newevt.SetPosition(
                acListBox->ScreenToClient(ClientToScreen(evt.GetPosition())));
            acListBox->ProcessWindowEvent(newevt);
        }
    }
    else
    {
        m_swx->DoMouseWheel(evt.GetWheelAxis(),
                            evt.GetWheelRotation(),
                            evt.GetWheelDelta(),
                            evt.GetLinesPerAction(),
                            evt.GetColumnsPerAction(),
                            evt.ControlDown(),
                            evt.IsPageScroll());
    }
}


void wxStyledTextCtrl::OnChar(wxKeyEvent& evt) {
    // On (some?) non-US PC keyboards the AltGr key is required to enter some
    // common characters.  It comes to us as both Alt and Ctrl down so we need
    // to let the char through in that case, otherwise if only ctrl or only
    // alt let's skip it.
    bool ctrl = evt.ControlDown();
#ifdef __WXMAC__
    // On the Mac the Alt key is just a modifier key (like Shift) so we need
    // to allow the char events to be processed when Alt is pressed.
    // TODO:  Should we check MetaDown instead in this case?
    bool alt = false;
#else
    bool alt  = evt.AltDown();
#endif
    bool skip = ((ctrl || alt) && ! (ctrl && alt));

#if wxUSE_UNICODE
    // apparently if we don't do this, Unicode keys pressed after non-char
    // ASCII ones (e.g. Enter, Tab) are not taken into account (patch 1615989)
    if (m_lastKeyDownConsumed && evt.GetUnicodeKey() > 255)
        m_lastKeyDownConsumed = false;
#endif

    if (!m_lastKeyDownConsumed && !skip) {
#if wxUSE_UNICODE
        int key = evt.GetUnicodeKey();
        bool keyOk = true;

        // if the unicode key code is not really a unicode character (it may
        // be a function key or etc., the platforms appear to always give us a
        // small value in this case) then fallback to the ascii key code but
        // don't do anything for function keys or etc.
        if (key <= 127) {
            key = evt.GetKeyCode();
            keyOk = (key <= 127);
        }
        if (keyOk) {
            m_swx->DoAddChar(key);
            return;
        }
#else
        int key = evt.GetKeyCode();
        if (key < WXK_START) {
            m_swx->DoAddChar(key);
            return;
        }
#endif
    }

    evt.Skip();
}


void wxStyledTextCtrl::OnKeyDown(wxKeyEvent& evt) {
    int processed = m_swx->DoKeyDown(evt, &m_lastKeyDownConsumed);
    if (!processed && !m_lastKeyDownConsumed)
        evt.Skip();
}


void wxStyledTextCtrl::OnLoseFocus(wxFocusEvent& evt) {
    m_swx->DoLoseFocus();
    evt.Skip();
}


void wxStyledTextCtrl::OnGainFocus(wxFocusEvent& evt) {
    m_swx->DoGainFocus();
    evt.Skip();
}


void wxStyledTextCtrl::OnDPIChanged(wxDPIChangedEvent& evt) {
    m_swx->DoInvalidateStyleData();

    // trigger a cursor change, so any cursors created by wxWidgets (like reverse arrow) will be recreated
    const int oldCursor = GetSTCCursor();
    SetSTCCursor(-1);
    SetSTCCursor(oldCursor);

    // adjust the margins to the new DPI
    for ( int i = 0; i < SC_MAX_MARGIN; ++i )
    {
        SetMarginWidth(i, (int)wxMulDivInt32(GetMarginWidth(i), evt.GetNewDPI().y, evt.GetOldDPI().y));
    }

    // Hide auto-complete popup, there is no (easy) way to set it to the correct size
    // and position
    if ( AutoCompActive() )
    {
        AutoCompCancel();
    }
}


void wxStyledTextCtrl::OnSysColourChanged(wxSysColourChangedEvent& WXUNUSED(evt)) {
    m_swx->DoInvalidateStyleData();
}


void wxStyledTextCtrl::OnEraseBackground(wxEraseEvent& WXUNUSED(evt)) {
    // do nothing to help avoid flashing
}



void wxStyledTextCtrl::OnMenu(wxCommandEvent& evt) {
    m_swx->DoCommand(evt.GetId());
}


void wxStyledTextCtrl::OnListBox(wxCommandEvent& WXUNUSED(evt)) {
    m_swx->DoOnListBox();
}


void wxStyledTextCtrl::OnIdle(wxIdleEvent& evt) {
    m_swx->DoOnIdle(evt);
}


void wxStyledTextCtrl::OnMouseCaptureLost(wxMouseCaptureLostEvent& WXUNUSED(evt)) {
    m_swx->DoMouseCaptureLost();
}


wxSize wxStyledTextCtrl::DoGetBestSize() const
{
    // What would be the best size for a wxSTC?
    // Just give a reasonable minimum until something else can be figured out.
    return FromDIP(wxSize(200,100));
}


//----------------------------------------------------------------------
// Turn notifications from Scintilla into events


void wxStyledTextCtrl::NotifyChange() {
    wxStyledTextEvent evt(wxEVT_STC_CHANGE, GetId());
    evt.SetEventObject(this);
    GetEventHandler()->ProcessEvent(evt);
}


static void SetEventText(wxStyledTextEvent& evt, const char* text,
                         size_t length) {
    if(!text) return;

    evt.SetString(stc2wx(text, length));
}


void wxStyledTextCtrl::NotifyParent(SCNotification* _scn) {
    SCNotification& scn = *_scn;
    wxStyledTextEvent evt(0, GetId());

    evt.SetEventObject(this);
    evt.SetPosition(scn.position);
    evt.SetKey(scn.ch);
    evt.SetModifiers(scn.modifiers);

    switch (scn.nmhdr.code) {
    case SCN_STYLENEEDED:
        evt.SetEventType(wxEVT_STC_STYLENEEDED);
        break;

    case SCN_CHARADDED:
        evt.SetEventType(wxEVT_STC_CHARADDED);
        break;

    case SCN_SAVEPOINTREACHED:
        evt.SetEventType(wxEVT_STC_SAVEPOINTREACHED);
        break;

    case SCN_SAVEPOINTLEFT:
        evt.SetEventType(wxEVT_STC_SAVEPOINTLEFT);
        break;

    case SCN_MODIFYATTEMPTRO:
        evt.SetEventType(wxEVT_STC_ROMODIFYATTEMPT);
        break;

    case SCN_DOUBLECLICK:
        evt.SetEventType(wxEVT_STC_DOUBLECLICK);
        evt.SetLine(scn.line);
        break;

    case SCN_UPDATEUI:
        evt.SetEventType(wxEVT_STC_UPDATEUI);
        evt.SetUpdated(scn.updated);
        break;

    case SCN_MODIFIED:
        evt.SetEventType(wxEVT_STC_MODIFIED);
        evt.SetModificationType(scn.modificationType);
        SetEventText(evt, scn.text, scn.length);
        evt.SetLength(scn.length);
        evt.SetLinesAdded(scn.linesAdded);
        evt.SetLine(scn.line);
        evt.SetFoldLevelNow(scn.foldLevelNow);
        evt.SetFoldLevelPrev(scn.foldLevelPrev);
        evt.SetToken(scn.token);
        evt.SetAnnotationLinesAdded(scn.annotationLinesAdded);
        break;

    case SCN_MACRORECORD:
        evt.SetEventType(wxEVT_STC_MACRORECORD);
        evt.SetMessage(scn.message);
        evt.SetWParam(scn.wParam);
        evt.SetLParam(scn.lParam);
        break;

    case SCN_MARGINCLICK:
        evt.SetEventType(wxEVT_STC_MARGINCLICK);
        evt.SetMargin(scn.margin);
        break;

    case SCN_NEEDSHOWN:
        evt.SetEventType(wxEVT_STC_NEEDSHOWN);
        evt.SetLength(scn.length);
        break;

    case SCN_PAINTED:
        evt.SetEventType(wxEVT_STC_PAINTED);
        break;

    case SCN_USERLISTSELECTION:
        evt.SetEventType(wxEVT_STC_USERLISTSELECTION);
        evt.SetListType(scn.listType);
        SetEventText(evt, scn.text, strlen(scn.text));
        evt.SetPosition(scn.lParam);
        evt.SetListCompletionMethod(scn.listCompletionMethod);
        break;

    case SCN_DWELLSTART:
        evt.SetEventType(wxEVT_STC_DWELLSTART);
        evt.SetX(scn.x);
        evt.SetY(scn.y);
        break;

    case SCN_DWELLEND:
        evt.SetEventType(wxEVT_STC_DWELLEND);
        evt.SetX(scn.x);
        evt.SetY(scn.y);
        break;

    case SCN_ZOOM:
        evt.SetEventType(wxEVT_STC_ZOOM);
        break;

    case SCN_HOTSPOTCLICK:
        evt.SetEventType(wxEVT_STC_HOTSPOT_CLICK);
        break;

    case SCN_HOTSPOTDOUBLECLICK:
        evt.SetEventType(wxEVT_STC_HOTSPOT_DCLICK);
        break;

    case SCN_HOTSPOTRELEASECLICK:
        evt.SetEventType(wxEVT_STC_HOTSPOT_RELEASE_CLICK);
        break;

    case SCN_INDICATORCLICK:
        evt.SetEventType(wxEVT_STC_INDICATOR_CLICK);
        break;

    case SCN_INDICATORRELEASE:
        evt.SetEventType(wxEVT_STC_INDICATOR_RELEASE);
        break;

    case SCN_CALLTIPCLICK:
        evt.SetEventType(wxEVT_STC_CALLTIP_CLICK);
        break;

    case SCN_AUTOCSELECTION:
        evt.SetEventType(wxEVT_STC_AUTOCOMP_SELECTION);
        evt.SetListType(scn.listType);
        SetEventText(evt, scn.text, strlen(scn.text));
        evt.SetPosition(scn.lParam);
        evt.SetListCompletionMethod(scn.listCompletionMethod);
        break;

    case SCN_AUTOCCANCELLED:
        evt.SetEventType(wxEVT_STC_AUTOCOMP_CANCELLED);
        break;

    case SCN_AUTOCCHARDELETED:
        evt.SetEventType(wxEVT_STC_AUTOCOMP_CHAR_DELETED);
        break;

    case SCN_AUTOCCOMPLETED:
        evt.SetEventType(wxEVT_STC_AUTOCOMP_COMPLETED);
        evt.SetListType(scn.listType);
        SetEventText(evt, scn.text, strlen(scn.text));
        evt.SetPosition(scn.lParam);
        evt.SetListCompletionMethod(scn.listCompletionMethod);
        break;

    case SCN_MARGINRIGHTCLICK:
        evt.SetEventType(wxEVT_STC_MARGIN_RIGHT_CLICK);
        evt.SetMargin(scn.margin);
        break;

    default:
        return;
    }

    GetEventHandler()->ProcessEvent(evt);
}

#ifdef __WXMSW__
WXLRESULT wxStyledTextCtrl::MSWWindowProc(WXUINT nMsg,
    WXWPARAM wParam,
    WXLPARAM lParam)
{
    switch(nMsg) {
    // Forward IME messages to ScintillaWX
    case WM_IME_KEYDOWN:
    case WM_IME_REQUEST:
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_SETCONTEXT:
        return SendMsg(nMsg, wParam, lParam);
    default:
        return wxControl::MSWWindowProc(nMsg, wParam, lParam);
    }
}
#endif


//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------

wxStyledTextEvent::wxStyledTextEvent(wxEventType commandType, int id)
    : wxCommandEvent(commandType, id)
{
    m_position = 0;
    m_key = 0;
    m_modifiers = 0;
    m_modificationType = 0;
    m_length = 0;
    m_linesAdded = 0;
    m_line = 0;
    m_foldLevelNow = 0;
    m_foldLevelPrev = 0;
    m_margin = 0;
    m_message = 0;
    m_wParam = 0;
    m_lParam = 0;
    m_listType = 0;
    m_x = 0;
    m_y = 0;
    m_token = 0;
    m_annotationLinesAdded = 0;
    m_updated = 0;
    m_listCompletionMethod = 0;

#if wxUSE_DRAG_AND_DROP
    m_dragFlags = wxDrag_CopyOnly;
    m_dragResult = wxDragNone;
#endif
}

bool wxStyledTextEvent::GetShift() const { return (m_modifiers & SCI_SHIFT) != 0; }
bool wxStyledTextEvent::GetControl() const { return (m_modifiers & SCI_CTRL) != 0; }
bool wxStyledTextEvent::GetAlt() const { return (m_modifiers & SCI_ALT) != 0; }


wxStyledTextEvent::wxStyledTextEvent(const wxStyledTextEvent& event):
  wxCommandEvent(event)
{
    m_position =      event.m_position;
    m_key =           event.m_key;
    m_modifiers =     event.m_modifiers;
    m_modificationType = event.m_modificationType;
    m_length =        event.m_length;
    m_linesAdded =    event.m_linesAdded;
    m_line =          event.m_line;
    m_foldLevelNow =  event.m_foldLevelNow;
    m_foldLevelPrev = event.m_foldLevelPrev;

    m_margin =        event.m_margin;

    m_message =       event.m_message;
    m_wParam =        event.m_wParam;
    m_lParam =        event.m_lParam;

    m_listType =     event.m_listType;
    m_x =            event.m_x;
    m_y =            event.m_y;

    m_token =        event.m_token;
    m_annotationLinesAdded = event.m_annotationLinesAdded;
    m_updated =      event.m_updated;
    m_listCompletionMethod = event.m_listCompletionMethod;

#if wxUSE_DRAG_AND_DROP
    m_dragFlags =    event.m_dragFlags;
    m_dragResult =   event.m_dragResult;
#endif
}

//----------------------------------------------------------------------
//----------------------------------------------------------------------

/*static*/ wxVersionInfo wxStyledTextCtrl::GetLibraryVersionInfo()
{
    return wxVersionInfo("Scintilla", 3, 7, 2, "Scintilla 3.7.2");
}

#endif // wxUSE_STC
